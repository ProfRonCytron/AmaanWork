<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Austin's Moving Knife Demo</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f7fafc;
            color: #2d3748;
        }

        .simulation-container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .step-indicator {
            text-align: center;
            font-weight: 600;
            margin: 15px 0;
            font-size: 1.1rem;
        }

        .phase-indicator {
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            border: 1px solid #e2e8f0;
        }

        .game-area {
            position: relative;
            width: 100%;
            height: 400px;
            border: 3px solid #2d3748;
            border-radius: 8px;
            margin: 20px 0;
            background: #f5f5f0;
            overflow: hidden;
        }

        .background-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .knife-line {
            stroke: #dc3545;
            stroke-width: 4;
            stroke-dasharray: 10,5;
            z-index: 5;
        }

            .knife-line.left-knife {
                stroke: #28a745;
            }

        .piece-overlay {
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 3;
        }

            .piece-overlay.selected {
                fill-opacity: 0.5 !important;
                stroke-width: 6 !important;
            }

        .button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            margin: 5px;
            transition: background 0.2s ease;
        }

            .button:hover:not(:disabled) {
                background: #2c5282;
            }

            .button:disabled {
                background: #a0aec0;
                cursor: not-allowed;
            }

            .button.danger {
                background: #e53e3e;
            }

                .button.danger:hover:not(:disabled) {
                    background: #c53030;
                }

        .instructions {
            background: #ebf8ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3182ce;
            margin: 20px 0;
        }

        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .player-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .player-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

            .player-card.active {
                border-color: #3182ce;
                background: #ebf8ff;
            }

        .color-legend {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
            padding: 10px;
            background: #ffffff;
            border-radius: 6px;
        }

        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            text-align: center;
        }

        .color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .valuation-input {
            width: 35px;
            padding: 2px 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            text-align: center;
            font-size: 11px;
        }

        .utility-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }

        .utility-fill {
            height: 100%;
            background: #3182ce;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .utility-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #2d3748;
        }

        .current-values {
            background: #f0f4f7;
            padding: 8px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 13px;
        }

        .player-card.invalid {
            border-color: #e53e3e !important;
            background: #fff5f5 !important;
        }

        .validation-indicator {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <div class="step-indicator" id="stepIndicator">
            Phase 1: Single knife moving across the cake
        </div>

        <div class="phase-indicator" id="phaseIndicator">
            Waiting for either player to call "STOP!" when they believe the left piece equals exactly 50%
        </div>

        <div class="instructions" id="instructions">
            <strong>Instructions:</strong> Watch the knife move across the cake. Either player can call "STOP!" when they think the left piece has exactly 50% value according to their preferences.
        </div>

        <div class="game-area" id="gameArea">
            <svg class="background-svg" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet">
                <!-- Blue region (top) -->
                <polygon points="0,0 600,0 600,150 0,150" fill="#0066ff" stroke="#2d3748" stroke-width="2" />
                <text x="300" y="80" text-anchor="middle" font-size="32" font-weight="bold" fill="white">Blue</text>

                <!-- Red region (top right) -->
                <polygon points="600,0 800,0 800,250 600,250" fill="#ff3366" stroke="#2d3748" stroke-width="2" />
                <text x="700" y="125" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Red</text>

                <!-- Orange region (right) -->
                <polygon points="600,250 800,250 800,350 600,350" fill="#ff6600" stroke="#2d3748" stroke-width="2" />
                <text x="700" y="310" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Orange</text>

                <!-- Purple region (bottom) -->
                <polygon points="150,350 800,350 800,400 150,400" fill="#9966ff" stroke="#2d3748" stroke-width="2" />
                <text x="500" y="380" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Purple</text>

                <!-- Pink region (bottom left) -->
                <polygon points="0,150 150,150 150,400 0,400" fill="#ff66ff" stroke="#2d3748" stroke-width="2" />
                <text x="80" y="280" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Pink</text>

                <!-- Green region (center) -->
                <polygon points="150,150 600,150 600,350 150,350" fill="#3f9633" stroke="#2d3748" stroke-width="2" />
                <text x="380" y="260" text-anchor="middle" font-size="32" font-weight="bold" fill="white">Green</text>

                <!-- Right knife -->
                <line id="rightKnife" x="0"  class="knife-line" />

                <!-- Second knife (hidden initially) -->
                <line id="leftKnife" x="0" class="knife-line left-knife" style="display: none;" />

                <!-- Piece overlays for selection -->
                <rect id="leftPiece" x="0" y="0" width="400" height="400"
                      fill="rgba(49,130,206,0.2)" stroke="#3182ce" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
                <rect id="middlePiece" x="200" y="0" width="200" height="400"
                      fill="rgba(255,193,7,0.2)" stroke="#ffc107" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
                <rect id="rightPiece" x="400" y="0" width="400" height="400"
                      fill="rgba(72,187,120,0.2)" stroke="#38a169" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
            </svg>
        </div>

        <div class="animation-controls">
            <button id="startButton" class="button">Play</button>
            <button id="pauseButton" class="button" style="display: none;">Pause</button>
            <button id="player1StopButton" class="button danger" style="display: none;">Player 1: STOP!</button>
            <button id="player2StopButton" class="button danger" style="display: none;">Player 2: STOP!</button>
        </div>

        <div class="player-info">
            <div class="player-card" id="player1Card">
                <h3>Player 1</h3>
                <div class="color-legend">
                    <div class="color-item">
                        <div class="color-swatch" style="background: #0066ff;"></div>
                        <span>Blue: <input type="number" class="valuation-input" id="p1-blue" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff3366;"></div>
                        <span>Red: <input type="number" class="valuation-input" id="p1-red" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #3f9633;"></div>
                        <span>Green: <input type="number" class="valuation-input" id="p1-green" value="25" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff6600;"></div>
                        <span>Orange: <input type="number" class="valuation-input" id="p1-orange" value="10" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff66ff;"></div>
                        <span>Pink: <input type="number" class="valuation-input" id="p1-pink" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #9966ff;"></div>
                        <span>Purple: <input type="number" class="valuation-input" id="p1-purple" value="15" min="0" max="100">pts</span>
                    </div>
                </div>
                <div class="current-values" id="p1-values">
                    <div><strong>Current Piece Value:</strong></div>
                    <div id="player1LeftValue">Left: 0.0</div>
                    <div id="player1CenterValue" style="display: none;">Center: 0.0</div>
                    <div id="player1FlankValue" style="display: none;">Flank: 0.0</div>
                </div>
                <div class="utility-bar">
                    <div class="utility-fill" id="p1-utility-fill"></div>
                    <div class="utility-text" id="p1-utility-text">0%</div>
                </div>
            </div>

            <div class="player-card" id="player2Card">
                <h3>Player 2</h3>
                <div class="color-legend">
                    <div class="color-item">
                        <div class="color-swatch" style="background: #0066ff;"></div>
                        <span>Blue: <input type="number" class="valuation-input" id="p2-blue" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff3366;"></div>
                        <span>Red: <input type="number" class="valuation-input" id="p2-red" value="25" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #3f9633;"></div>
                        <span>Green: <input type="number" class="valuation-input" id="p2-green" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff6600;"></div>
                        <span>Orange: <input type="number" class="valuation-input" id="p2-orange" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff66ff;"></div>
                        <span>Pink: <input type="number" class="valuation-input" id="p2-pink" value="10" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #9966ff;"></div>
                        <span>Purple: <input type="number" class="valuation-input" id="p2-purple" value="10" min="0" max="100">pts</span>
                    </div>
                </div>
                <div class="current-values" id="p2-values">
                    <div><strong>Current Piece Value:</strong></div>
                    <div id="player2LeftValue">Left: 0.0</div>
                    <div id="player2CenterValue" style="display: none;">Center: 0.0</div>
                    <div id="player2FlankValue" style="display: none;">Flank: 0.0</div>
                </div>
                <div class="utility-bar">
                    <div class="utility-fill" id="p2-utility-fill"></div>
                    <div class="utility-text" id="p2-utility-text">0%</div>
                </div>
                
            </div>
        </div>

        <div style="text-align: center; margin: 20px 0;">
            <button id="resetButton" class="button">Reset Demo</button>
        </div>
    </div>

    <script>
        // Game state initialization
        let gameState = {
            phase: 1,
            isAnimating: false,
            isPaused: false,
            stopPosition: null,
            leftKnifePosition: 0,
            rightKnifePosition: 0,
            controllingPlayer: null,
            animationSpeed: 0.5,
            animationId: null,
            targetMiddleValue: null,
        };

        const colorValues = {
            player1: { blue: 20, red: 15, green: 25, orange: 10, pink: 15, purple: 15 },
            player2: { blue: 15, red: 25, green: 20, orange: 20, pink: 10, purple: 10 }
        };

        const regions = {
            blue: { x1: 0, y1: 0, x2: 600, y2: 150 },
            red: { x1: 600, y1: 0, x2: 800, y2: 250 },
            orange: { x1: 600, y1: 250, x2: 800, y2: 350 },
            purple: { x1: 150, y1: 350, x2: 800, y2: 400 },
            pink: { x1: 0, y1: 150, x2: 150, y2: 400 },
            green: { x1: 150, y1: 150, x2: 600, y2: 350 }
        };

        // CORE CALCULATION FUNCTIONS

        // returns an object with the values of the left and the right regions (called each frame)
        function calculatePhase1RegionValues() {
            const leftValues = {};
            const rightValues = {};

            // For each color region, calculate 2D intersection
            for (const [color, bounds] of Object.entries(regions)) {
                if (gameState.rightKnifePosition <= bounds.x1) { // knife is entirely to the left, region is entirely in the right
                    leftValues[color] = 0;
                    rightValues[color] = 100;
                } else if (gameState.rightKnifePosition >= bounds.x2) { // knife is entirely to the right, region is entirely in the left
                    leftValues[color] = 100;
                    rightValues[color] = 0;
                } else { // knife intersects the region
                    const totalArea = (bounds.x2 - bounds.x1) * (bounds.y2 - bounds.y1);
                    const leftArea = (gameState.rightKnifePosition - bounds.x1) * (bounds.y2 - bounds.y1);
                    const leftPercent = (leftArea / totalArea) * 100;
                    leftValues[color] = leftPercent;
                    rightValues[color] = 100 - leftPercent;
                }
            }

            return { left: leftValues, right: rightValues };
        }

        // returns an object with the values of the middle and flank regions in phase 2 (called each frame)
        function calculatePhase2RegionValues() {
            const middleValues = {};
            const flankValues = {};

            for (const [color, bounds] of Object.entries(regions)) {
                const totalArea = (bounds.x2 - bounds.x1) * (bounds.y2 - bounds.y1);

                if (gameState.leftKnifePosition <= bounds.x1 && gameState.rightKnifePosition >= bounds.x2) {
                    // Color region is completely between both knives
                    middleValues[color] = 100;
                    flankValues[color] = 0;
                } else if (gameState.leftKnifePosition >= bounds.x2 || gameState.rightKnifePosition <= bounds.x1) {
                    // Color region is completely outside both knives
                    middleValues[color] = 0;
                    flankValues[color] = 100;
                } else {
                    // Knives intersect the region - calculate actual overlap
                    const leftBound = Math.max(gameState.leftKnifePosition, bounds.x1);
                    const rightBound = Math.min(gameState.rightKnifePosition, bounds.x2);

                    if (leftBound < rightBound) {
                        // There is overlap between knives within this region
                        const middleArea = (rightBound - leftBound) * (bounds.y2 - bounds.y1);
                        const middlePercent = (middleArea / totalArea) * 100;
                        middleValues[color] = middlePercent;
                        flankValues[color] = 100 - middlePercent;
                    } else {
                        // No overlap - region is entirely in flank
                        middleValues[color] = 0;
                        flankValues[color] = 100;
                    }
                }
            }

            return { middle: middleValues, flank: flankValues };
        }

        // returns how much a specific player values a region
        function calculatePlayerValue(regionValues, player) {
            let total = 0;
            const prefs = colorValues[player];

            for (const [color, amount] of Object.entries(regionValues)) {
                total += (amount / 100) * prefs[color];
            }

            return total;
        }

        // UTILITY AND VALIDATION FUNCTIONS

        // function that updates color valuations based on what is currently inputted
        function updateColorValues() {
            colorValues.player1 = {
                blue: parseInt(document.getElementById('p1-blue').value) || 0,
                red: parseInt(document.getElementById('p1-red').value) || 0,
                green: parseInt(document.getElementById('p1-green').value) || 0,
                orange: parseInt(document.getElementById('p1-orange').value) || 0,
                pink: parseInt(document.getElementById('p1-pink').value) || 0,
                purple: parseInt(document.getElementById('p1-purple').value) || 0
            };

            colorValues.player2 = {
                blue: parseInt(document.getElementById('p2-blue').value) || 0,
                red: parseInt(document.getElementById('p2-red').value) || 0,
                green: parseInt(document.getElementById('p2-green').value) || 0,
                orange: parseInt(document.getElementById('p2-orange').value) || 0,
                pink: parseInt(document.getElementById('p2-pink').value) || 0,
                purple: parseInt(document.getElementById('p2-purple').value) || 0
            };
        }

        // function that updates validation status of valuations
        function updateValidationStatus() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            // Update or create validation indicators
            updatePlayerValidation('player1', p1Total);
            updatePlayerValidation('player2', p2Total);
        }

        // helper function called in updateValidationStatus() for both players
        function updatePlayerValidation(player, total) {
            const playerCard = document.getElementById(`${player}Card`);
            const cardNumber = player === 'player1' ? '1' : '2';

            // Remove existing validation indicator
            const existingIndicator = playerCard.querySelector('.validation-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Create new validation indicator
            const indicator = document.createElement('div');
            indicator.className = 'validation-indicator';
            indicator.style.cssText = `
                margin: 8px 0;
                padding: 6px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
            `;

            if (total === 100) {
                indicator.textContent = `Total: ${total} points`;
                indicator.style.background = '#f0fff4';
                indicator.style.color = '#38a169';
                indicator.style.border = '1px solid #68d391';
                playerCard.classList.remove('invalid');
            } else {
                indicator.textContent = `Total: ${total} points (needs 100)`;
                indicator.style.background = '#fff5f5';
                indicator.style.color = '#e53e3e';
                indicator.style.border = '1px solid #fc8181';
                playerCard.classList.add('invalid');
            }

            // Insert after the color legend
            const colorLegend = playerCard.querySelector('.color-legend');
            colorLegend.insertAdjacentElement('afterend', indicator);
        }

        // updates utility bars based on value information
        function updateUtilityBars(p1Value, p2Value) {
            const p1Fill = document.getElementById('p1-utility-fill');
            const p1Text = document.getElementById('p1-utility-text');
            const p2Fill = document.getElementById('p2-utility-fill');
            const p2Text = document.getElementById('p2-utility-text');

            p1Fill.style.width = `${p1Value}%`;
            p1Text.textContent = `${Math.round(p1Value)}%`;

            p2Fill.style.width = `${p2Value}%`;
            p2Text.textContent = `${Math.round(p2Value)}%`;
        }

        // updates state of start button based on whether all information is valid
        function updateStartButtonState() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            const startButton = document.getElementById('startButton');
            const isValid = p1Total === 100 && p2Total === 100;

            startButton.disabled = !isValid;
            startButton.textContent = isValid ? 'Start Animation' : 'Fix Valuations First';
        }

        // handles changes in valuations (calls helper functions)
        function handleValuationChange() {
            updateColorValues();
            updateValidationStatus();
            updateStartButtonState();

            if (gameState.phase === 1 && gameState.isAnimating) {
                updateKnifePosition(gameState.rightKnifePosition);
            }
        }

        // function that validates current color values
        function validateTotals() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);
            return p1Total === 100 && p2Total === 100;
        }

        // ANIMATION FUNCTIONS

        // Update the position of a knife (phase 1)
        function updateKnifePosition(newPosition) {
            gameState.rightKnifePosition += newPosition;
            const knife = document.getElementById('rightKnife');
            knife.setAttribute('x1', gameState.rightKnifePosition);
            knife.setAttribute('y1', 0);
            knife.setAttribute('x2', gameState.rightKnifePosition);
            knife.setAttribute('y2', 400);

            // Calculate and update values
            const regionValues = calculatePhase1RegionValues();
            const p1Left = calculatePlayerValue(regionValues.left, 'player1');
            const p2Left = calculatePlayerValue(regionValues.left, 'player2');

            document.getElementById('player1LeftValue').textContent = `Left: ${Math.round(p1Left)}`;
            document.getElementById('player2LeftValue').textContent = `Left: ${Math.round(p2Left)}`;

            updateUtilityBars(p1Left, p2Left);
        }

        function showStopPosition() {
            // Add a visual indicator for where the left knife needs to reach
            const svg = document.querySelector('.background-svg');

            // Remove existing indicator if present
            const existingIndicator = document.getElementById('stopPositionIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Add new indicator
            const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            indicator.setAttribute('id', 'stopPositionIndicator');
            indicator.setAttribute('x1', gameState.stopPosition);
            indicator.setAttribute('y1', 0);
            indicator.setAttribute('x2', gameState.stopPosition);
            indicator.setAttribute('y2', 400);
            indicator.setAttribute('stroke', '#ffa500');
            indicator.setAttribute('stroke-width', '3');
            indicator.setAttribute('stroke-dasharray', '5,5');
            indicator.setAttribute('opacity', '0.7');

            svg.appendChild(indicator);
        }

        // functions starts the demo
        function startAnimation() {
            updateColorValues();

            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            if (p1Total !== 100 || p2Total !== 100) {
                alert(`Valuation totals must equal 100 points each!\n\nPlayer 1 total: ${p1Total}\nPlayer 2 total: ${p2Total}\n\nPlease adjust the values.`);
                return;
            }

            gameState.isAnimating = true;
            gameState.phase = 1;
            gameState.rightKnifePosition = 0;

            document.getElementById('startButton').style.display = 'none';
            document.getElementById('pauseButton').style.display = 'inline-block';
            document.getElementById('player1StopButton').style.display = 'inline-block';
            document.getElementById('player2StopButton').style.display = 'inline-block';

            animateKnife();
        }

        function animateKnife() {
            if (!gameState.isAnimating || gameState.isPaused) return;

            // Calculate current values for both players
            const regionValues = calculatePhase1RegionValues();
            const p1Left = calculatePlayerValue(regionValues.left, 'player1');
            const p2Left = calculatePlayerValue(regionValues.left, 'player2');

            // check if knife has reached end of the cake
            if (gameState.rightKnifePosition >= 800) {
                gameState.rightKnifePosition = 0; // Reset to start
            }

            // Calculate how close each player is to 50%
            const p1Distance = Math.abs(p1Left - 50);
            const p2Distance = Math.abs(p2Left - 50);

            // Use the minimum distance (closest player to 50%)
            const minDistance = Math.min(p1Distance, p2Distance);
            const speedMultiplier = calculateSpeedMultiplier(minDistance);

            // Calculate new position based on speed multiplier
            const posToAdd = gameState.animationSpeed * 0.5 * speedMultiplier;

            updateKnifePosition(posToAdd);
            gameState.animationId = requestAnimationFrame(animateKnife);
        }

        function calculateSpeedMultiplier(minDistance) {
            // Calculate speed multiplier based on distance
            // When very close (distance < 2): slow down to 0.1x speed
            // When far (distance > 20): speed up to 2x speed
            // Linear interpolation between these points
            let speedMultiplier;
            if (minDistance < 2) {
                // Very close to 50% - slow way down
                speedMultiplier = 0.1 + (minDistance / 2) * 0.4; // 0.1x to 0.5x speed
            } else if (minDistance < 10) {
                // Somewhat close - moderate speed
                speedMultiplier = 0.5 + ((minDistance - 2) / 8) * 0.5; // 0.5x to 1.0x speed
            } else if (minDistance < 20) {
                // Not close - normal to fast speed
                speedMultiplier = 1.0 + ((minDistance - 10) / 10) * 1.0; // 1.0x to 2.0x speed
            } else {
                // Very far - maximum speed
                speedMultiplier = 2.0;
            }
            return speedMultiplier;
        }

        function pauseAnimation() {
            gameState.isPaused = !gameState.isPaused;
            const pauseBtn = document.getElementById('pauseButton');

            if (gameState.isPaused) {
                pauseBtn.textContent = 'Resume';
            } else {
                pauseBtn.textContent = 'Pause';
                animateKnife();
            }
        }

        function stopPhase1(player) {
            gameState.isAnimating = false;
            gameState.controllingPlayer = player;
            gameState.stopPosition = gameState.rightKnifePosition;

            // Calculate what the middle piece would be worth if it matched their 50% assessment
            const regionValues = calculatePhase1RegionValues();
            const controllingPlayerKey = `player${player}`;
            const leftPieceValue = calculatePlayerValue(regionValues.left, controllingPlayerKey);
            gameState.targetMiddleValue = leftPieceValue;

            gameState.phase = 2;

            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }

            document.getElementById('pauseButton').style.display = 'none';
            document.getElementById('player1StopButton').style.display = 'none';
            document.getElementById('player2StopButton').style.display = 'none';

            document.getElementById('stepIndicator').textContent = 'Phase 2: Dual knife movement with value constraint';
            document.getElementById('phaseIndicator').textContent =
                `Player ${player} controls both knives. Left knife moves toward position ${Math.round(gameState.stopPosition)}, maintaining exactly ${Math.round(gameState.targetMiddleValue)} value in middle piece`;

            startPhase2();
        }

        function updateKnifePositions(newLeftPosition, newRightPosition) {
            gameState.leftKnifePosition = newLeftPosition;  
            gameState.rightKnifePosition = newRightPosition; 

            const leftKnife = document.getElementById('leftKnife');
            const rightKnife = document.getElementById('rightKnife');

            // Set the knife line positions
            leftKnife.setAttribute('x1', newLeftPosition);
            leftKnife.setAttribute('y1', 0);
            leftKnife.setAttribute('x2', newLeftPosition);
            leftKnife.setAttribute('y2', 400);

            rightKnife.setAttribute('x1', newRightPosition);
            rightKnife.setAttribute('y1', 0);
            rightKnife.setAttribute('x2', newRightPosition);
            rightKnife.setAttribute('y2', 400);

            // Calculate and update values
            const regionValues = calculatePhase2RegionValues();
            const p1Middle = calculatePlayerValue(regionValues.middle, 'player1');
            const p1Flank = calculatePlayerValue(regionValues.flank, 'player1');
            const p2Middle = calculatePlayerValue(regionValues.middle, 'player2');
            const p2Flank = calculatePlayerValue(regionValues.flank, 'player2');

            document.getElementById('player1CenterValue').textContent = `Center: ${Math.round(p1Middle)}`;
            document.getElementById('player1FlankValue').textContent = `Flank: ${Math.round(p1Flank)}`;
            document.getElementById('player2CenterValue').textContent = `Center: ${Math.round(p2Middle)}`;
            document.getElementById('player2FlankValue').textContent = `Flank: ${Math.round(p2Flank)}`;

            updateUtilityBars(p1Middle, p2Middle); // Show middle values during phase 2
        }

        function startPhase2() {
            // Show both knives
            const leftKnife = document.getElementById('leftKnife');
            leftKnife.style.display = 'block';

            showStopPosition();

            document.getElementById('instructions').innerHTML =
                '<strong>Phase 2:</strong> The controlling player\'s knives move automatically. The left knife (green) must reach the orange dashed line by the time the right knife (red) reaches the end, while maintaining the exact middle piece value.';

            // Initialize positions - left knife starts at beginning, right knife at stop position
            gameState.leftKnifePosition = 0;

            // Calculate where right knife should start so middle piece has correct value
            gameState.rightKnifePosition = findRightKnifePosition(0, gameState.targetMiddleValue, `player${gameState.controllingPlayer}`);

            // Show center and flank value displays
            document.getElementById('player1CenterValue').style.display = 'block';
            document.getElementById('player1FlankValue').style.display = 'block';
            document.getElementById('player2CenterValue').style.display = 'block';
            document.getElementById('player2FlankValue').style.display = 'block';

            // Hide left value displays
            document.getElementById('player1LeftValue').style.display = 'none';
            document.getElementById('player2LeftValue').style.display = 'none';

            // Update knife positions
            updateKnifePositions(gameState.leftKnifePosition, gameState.rightKnifePosition);

            // Add stop button for the other player
            const otherPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            const stopButton = document.createElement('button');
            stopButton.textContent = `Player ${otherPlayer}: STOP!`;
            stopButton.className = 'button danger';
            stopButton.onclick = () => startPhase3();

            document.querySelector('.animation-controls').appendChild(stopButton);

            // Start dual knife animation
            setTimeout(() => {
                gameState.isAnimating = true;
                animateDualKnives();
            }, 1000);
        }

        function calculatePhase2SpeedMultiplier(valueDistance) {
            // Similar logic to Phase 1 but adjusted for value constraints
            let speedMultiplier;
            if (valueDistance < 1) {
                // Very close to target value - slow way down
                speedMultiplier = 0.1 + (valueDistance / 1) * 0.4; // 0.1x to 0.5x speed
            } else if (valueDistance < 5) {
                // Somewhat close - moderate speed
                speedMultiplier = 0.5 + ((valueDistance - 1) / 4) * 0.5; // 0.5x to 1.0x speed
            } else if (valueDistance < 10) {
                // Not close - normal to fast speed
                speedMultiplier = 1.0 + ((valueDistance - 5) / 5) * 1.0; // 1.0x to 2.0x speed
            } else {
                // Very far - maximum speed
                speedMultiplier = 2.0;
            }
            return speedMultiplier;
        }

        function animateDualKnives() {
            if (!gameState.isAnimating || gameState.isPaused) return;

            const leftTarget = gameState.stopPosition;
            const rightTarget = 800;
            const controllingPlayerKey = `player${gameState.controllingPlayer}`;

            // Move left knife steadily toward target
            const leftRemaining = leftTarget - gameState.leftKnifePosition;
            const baseSpeed = 1.5;

            // Calculate current middle value and distance from target
            const currentRegionValues = calculatePhase2RegionValues();
            const currentMiddleValue = calculatePlayerValue(currentRegionValues.middle, controllingPlayerKey);
            const valueDistance = Math.abs(currentMiddleValue - gameState.targetMiddleValue);

            // Convert value distance to a percentage-like scale for speed calculation
            const percentageDistance = (valueDistance / gameState.targetMiddleValue) * 50; // Scale to 0-50 range
            const speedMultiplier = calculatePhase2SpeedMultiplier(percentageDistance);
            const adjustedSpeed = baseSpeed * speedMultiplier;

            // Move left knife steadily toward target (only if not already there)
            let newLeftPosition = gameState.leftKnifePosition;
            if (Math.abs(leftRemaining) > 1) {
                const leftStep = Math.sign(leftRemaining) * Math.min(Math.abs(leftRemaining), adjustedSpeed);
                newLeftPosition = gameState.leftKnifePosition + leftStep;
            } else {
                newLeftPosition = leftTarget; // Snap to target and stop moving
            }

            // Calculate right knife position that maintains the target value
            let newRightPosition;
            if (Math.abs(leftTarget - newLeftPosition) < 1) {
                // Left knife has reached target, right knife can move freely toward end
                const rightRemaining = rightTarget - gameState.rightKnifePosition;
                if (Math.abs(rightRemaining) > 1) {
                    newRightPosition = gameState.rightKnifePosition + Math.sign(rightRemaining) * Math.min(Math.abs(rightRemaining), adjustedSpeed);
                } else {
                    newRightPosition = rightTarget;
                }
            } else {
                // Left knife still moving, maintain value constraint
                newRightPosition = findRightKnifePosition(newLeftPosition, gameState.targetMiddleValue, controllingPlayerKey);
            }

            // Ensure right knife doesn't go beyond bounds or past left knife
            newRightPosition = Math.max(newLeftPosition + 10, Math.min(newRightPosition, rightTarget));

            // Update positions
            updateKnifePositions(newLeftPosition, newRightPosition);

            // Check if left knife has reached its target
            let leftKnifeComplete = Math.abs(leftTarget - newLeftPosition) < 1;
            if (leftKnifeComplete) {
                newLeftPosition = leftTarget; // Lock left knife at target position
            }

            // Check if right knife has reached the end
            let rightKnifeComplete = Math.abs(rightTarget - newRightPosition) < 1;
            if (rightKnifeComplete) {
                newRightPosition = rightTarget; // Lock right knife at end
            }

            // Update positions
            updateKnifePositions(newLeftPosition, newRightPosition);

            // Only end animation when BOTH knives have reached their targets
            if (leftKnifeComplete && rightKnifeComplete) {
                setTimeout(() => startPhase3(), 500);
                return;
            }

            // Continue animation
            gameState.animationId = requestAnimationFrame(animateDualKnives);
        }

        // New helper function to find the right knife position
        function findRightKnifePosition(leftPos, targetValue, controllingPlayerKey) {
            // Binary search for the correct right knife position
            let minRight = leftPos + 1;
            let maxRight = 800;
            let bestRightPos = (minRight + maxRight) / 2;
            let bestValueDiff = Infinity;

            // Convergence threshold
            const tolerance = 0.1;
            const maxIterations = 50;

            for (let iterations = 0; iterations < maxIterations; iterations++) {
                const testRightPos = (minRight + maxRight) / 2;

                // Bounds check
                if (testRightPos <= leftPos || testRightPos > 800) {
                    break;
                }

                const testMiddleValues = calculateTestMiddleValues(leftPos, testRightPos);
                const testValue = calculatePlayerValue(testMiddleValues, controllingPlayerKey);
                const valueDiff = testValue - targetValue;

                // Check for convergence
                if (Math.abs(valueDiff) < tolerance) {
                    return testRightPos;
                }

                // Update search bounds
                if (valueDiff < 0) {
                    // Middle piece value too low, need to expand (move right knife right)
                    minRight = testRightPos;
                } else {
                    // Middle piece value too high, need to contract (move right knife left)
                    maxRight = testRightPos;
                }

                // Track best position found so far
                if (Math.abs(valueDiff) < Math.abs(bestValueDiff)) {
                    bestValueDiff = valueDiff;
                    bestRightPos = testRightPos;
                }

                // Check if search space collapsed
                if (maxRight - minRight < 0.1) {
                    break;
                }
            }

            // Ensure returned position is within valid bounds
            return Math.max(leftPos + 1, Math.min(bestRightPos, 800));
        }

        // Helper function to calculate middle values for test positions
        function calculateTestMiddleValues(leftPos, rightPos) {
            const middleValues = {};

            for (const [color, bounds] of Object.entries(regions)) {
                const totalArea = (bounds.x2 - bounds.x1) * (bounds.y2 - bounds.y1);

                if (leftPos <= bounds.x1 && rightPos >= bounds.x2) {
                    // Color region is completely between both knives
                    middleValues[color] = 100;
                } else if (leftPos >= bounds.x2 || rightPos <= bounds.x1) {
                    // Color region is completely outside both knives
                    middleValues[color] = 0;
                } else {
                    // Calculate actual overlap
                    const leftBound = Math.max(leftPos, bounds.x1);
                    const rightBound = Math.min(rightPos, bounds.x2);

                    if (leftBound < rightBound) {
                        const middleArea = (rightBound - leftBound) * (bounds.y2 - bounds.y1);
                        const middlePercent = (middleArea / totalArea) * 100;
                        middleValues[color] = middlePercent;
                    } else {
                        middleValues[color] = 0;
                    }
                }
            }

            return middleValues;
        }

        function startPhase3() {
            gameState.isAnimating = false;
            gameState.phase = 3;

            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }

            document.getElementById('stepIndicator').textContent = 'Phase 3: Random Assignment';

            const choosingPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            document.getElementById('phaseIndicator').textContent = `Randomly assigning pieces...`;
            document.getElementById('instructions').innerHTML = '<strong>Random Assignment:</strong> The pieces will be randomly assigned to ensure fairness.';

            // Show piece overlays for visualization
            const leftPiece = document.getElementById('leftPiece');
            const middlePiece = document.getElementById('middlePiece');
            const rightPiece = document.getElementById('rightPiece');

            leftPiece.setAttribute('width', gameState.leftKnifePosition);
            leftPiece.style.display = 'block';

            middlePiece.setAttribute('x', gameState.leftKnifePosition);
            middlePiece.setAttribute('width', gameState.rightKnifePosition - gameState.leftKnifePosition);
            middlePiece.style.display = 'block';

            rightPiece.setAttribute('x', gameState.rightKnifePosition);
            rightPiece.setAttribute('width', 800 - gameState.rightKnifePosition);
            rightPiece.style.display = 'block';

            // Remove click handlers
            leftPiece.onclick = null;
            middlePiece.onclick = null;
            rightPiece.onclick = null;

            // Randomly assign after a brief delay
            setTimeout(() => {
                const randomChoice = Math.random() < 0.5 ? 'inside' : 'outside';
                performRandomAssignment(randomChoice, choosingPlayer);
            }, 2000);
        }

        function performRandomAssignment(randomChoice, choosingPlayer) {
            // Highlight the randomly selected piece briefly
            const selectedOverlay = randomChoice === 'inside' ?
                document.getElementById('middlePiece') :
                [document.getElementById('leftPiece'), document.getElementById('rightPiece')];

            if (Array.isArray(selectedOverlay)) {
                selectedOverlay.forEach(piece => {
                    piece.style.stroke = '#ffd700';
                    piece.style.strokeWidth = '6';
                    piece.style.fillOpacity = '0.6';
                });
            } else {
                selectedOverlay.style.stroke = '#ffd700';
                selectedOverlay.style.strokeWidth = '6';
                selectedOverlay.style.fillOpacity = '0.6';
            }

            // Update phase indicator to show the result
            document.getElementById('phaseIndicator').textContent =
                `Random assignment complete! Player ${choosingPlayer} received the ${randomChoice} piece.`;

            // Show results after brief highlight
            setTimeout(() => {
                performFinalCalculation(randomChoice, choosingPlayer);
            }, 1500);
        }

        function performFinalCalculation(selectedPiece, choosingPlayer) {
            gameState.isAnimating = false;

            // Calculate final values for the two actual pieces
            const regionValues = calculatePhase2RegionValues();
            const middleValues = regionValues.middle;
            const flankValues = regionValues.flank;

            const p1Inside = calculatePlayerValue(middleValues, 'player1');
            const p1Outside = calculatePlayerValue(flankValues, 'player1');

            const p2Inside = calculatePlayerValue(middleValues, 'player2');
            const p2Outside = calculatePlayerValue(flankValues, 'player2');

            const controllingPlayer = gameState.controllingPlayer;

            // Show results
            showResults(selectedPiece, choosingPlayer, controllingPlayer, {
                inside: { p1: p1Inside, p2: p2Inside },
                outside: { p1: p1Outside, p2: p2Outside }
            });
        }

        function selectPiece(piece) {
            gameState.isAnimating = false;

            // Calculate final values for the two actual pieces
            const middleValues = calculateMiddleRegionValues(gameState.leftKnifePosition, gameState.rightKnifePosition);

            // Calculate outside piece (left + right combined)
            const leftValues = calculateRegionValues(gameState.leftKnifePosition).left;
            const rightValues = calculateRegionValues(gameState.rightKnifePosition).right;

            // Combine left and right for outside piece
            const outsideValues = {};
            for (const color in leftValues) {
                outsideValues[color] = leftValues[color] + rightValues[color];
            }

            const p1Inside = calculatePlayerValue(middleValues, 'player1');
            const p1Outside = calculatePlayerValue(outsideValues, 'player1');

            const p2Inside = calculatePlayerValue(middleValues, 'player2');
            const p2Outside = calculatePlayerValue(outsideValues, 'player2');

            // Determine what the choosing player selected
            const choosingPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            const controllingPlayer = gameState.controllingPlayer;

            // Convert click to actual choice (left/right clicks both mean "outside")
            const actualChoice = piece === 'middle' ? 'inside' : 'outside';

            // Show results
            showResults(actualChoice, choosingPlayer, controllingPlayer, {
                inside: { p1: p1Inside, p2: p2Inside },
                outside: { p1: p1Outside, p2: p2Outside }
            });
        }

        function showResults(selectedPiece, choosingPlayer, controllingPlayer, allValues) {
            // Hide the game area and show results
            document.getElementById('gameArea').style.display = 'none';
            document.querySelector('.animation-controls').style.display = 'none';

            // Create results display
            const resultsHTML = `
                <div id="resultsSection" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h2 style="text-align: center; color: #2d3748; margin-bottom: 20px;">Results</h2>
            
                    <div style="background: white; padding: 15px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #3182ce;">
                        <h3>Protocol Summary:</h3>
                        <p><strong>Phase 1:</strong> Player ${controllingPlayer} stopped the knife when they believed the left portion was worth exactly 50% to them.</p>
                        <p><strong>Phase 2:</strong> Player ${controllingPlayer} controlled both knives, maintaining their 50% value constraint in the middle piece.</p>
                        <p><strong>Phase 3:</strong> The pieces were <strong>randomly assigned</strong>. Player ${choosingPlayer} received the <strong>${selectedPiece} piece</strong>.</p>
                    </div>
            
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div style="background: white; padding: 20px; border-radius: 6px; text-align: center; ${selectedPiece === 'inside' ? 'border: 3px solid #3182ce;' : 'border: 1px solid #e2e8f0;'}">
                            <h4 style="color: #ffc107; margin-bottom: 15px;">Inside Piece (Middle)</h4>
                            <div style="background: #fff8e1; padding: 10px; border-radius: 4px; margin: 10px 0;">
                                <p style="margin: 5px 0;">Player 1 Value: <strong>${Math.round(allValues.inside.p1)}</strong> points</p>
                                <p style="margin: 5px 0;">Player 2 Value: <strong>${Math.round(allValues.inside.p2)}</strong> points</p>
                            </div>
                            ${selectedPiece === 'inside' ? '<p style="color: #3182ce; font-weight: bold; margin-top: 10px;">✓ SELECTED</p>' : ''}
                        </div>
                
                        <div style="background: white; padding: 20px; border-radius: 6px; text-align: center; ${selectedPiece === 'outside' ? 'border: 3px solid #3182ce;' : 'border: 1px solid #e2e8f0;'}">
                            <h4 style="color: #38a169; margin-bottom: 15px;">Outside Piece (Left + Right)</h4>
                            <div style="background: #f0fff4; padding: 10px; border-radius: 4px; margin: 10px 0;">
                                <p style="margin: 5px 0;">Player 1 Value: <strong>${Math.round(allValues.outside.p1)}</strong> points</p>
                                <p style="margin: 5px 0;">Player 2 Value: <strong>${Math.round(allValues.outside.p2)}</strong> points</p>
                            </div>
                            ${selectedPiece === 'outside' ? '<p style="color: #3182ce; font-weight: bold; margin-top: 10px;">✓ SELECTED</p>' : ''}
                        </div>
                    </div>
            
                    <div style="background: #ebf8ff; padding: 15px; border-radius: 6px; margin: 20px 0;">
                        <h3 style="color: #2d3748;">Random Assignment Result:</h3>
                        <p><strong>Player ${choosingPlayer}</strong> was randomly assigned the <strong>${selectedPiece}</strong> piece → <strong>${Math.round(choosingPlayer === 1 ? allValues[selectedPiece].p1 : allValues[selectedPiece].p2)} points</strong></p>
                        <p><strong>Player ${controllingPlayer}</strong> gets the remaining <strong>${selectedPiece === 'inside' ? 'outside' : 'inside'}</strong> piece → <strong>${Math.round(controllingPlayer === 1 ? allValues[selectedPiece === 'inside' ? 'outside' : 'inside'].p1 : allValues[selectedPiece === 'inside' ? 'outside' : 'inside'].p2)} points</strong></p>
                    </div>
                </div>
            `;

            // Insert results after the player info
            document.querySelector('.player-info').insertAdjacentHTML('afterend', resultsHTML);

            // Update step indicator
            document.getElementById('stepIndicator').textContent = 'Demo Complete - Results';
            document.getElementById('phaseIndicator').textContent = `Player ${choosingPlayer} selected the ${selectedPiece} piece. Fair division achieved!`;
        }

        function resetDemo() {
            location.reload();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {
            document.getElementById('startButton').addEventListener('click', startAnimation);
            document.getElementById('pauseButton').addEventListener('click', pauseAnimation);
            document.getElementById('player1StopButton').addEventListener('click', () => stopPhase1(1));
            document.getElementById('player2StopButton').addEventListener('click', () => stopPhase1(2));
            document.getElementById('resetButton').addEventListener('click', resetDemo);

            // Add event listeners for valuation inputs
            ['p1-blue', 'p1-red', 'p1-green', 'p1-orange', 'p1-pink', 'p1-purple',
                'p2-blue', 'p2-red', 'p2-green', 'p2-orange', 'p2-pink', 'p2-purple'].forEach(id => {
                    document.getElementById(id).addEventListener('input', handleValuationChange);
                });

            // Initialize values
            updateColorValues();
            updateValidationStatus();
            updateStartButtonState();
            updateKnifePosition(0);
        });
    </script>
</body>
</html>