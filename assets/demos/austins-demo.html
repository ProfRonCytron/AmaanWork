<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Austin's Moving Knife Demo</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f7fafc;
            color: #2d3748;
        }

        .simulation-container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
        }

        .step-indicator {
            text-align: center;
            font-weight: 600;
            margin: 15px 0;
            font-size: 1.1rem;
        }

        .phase-indicator {
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            border: 1px solid #e2e8f0;
        }

        .game-area {
            position: relative;
            width: 100%;
            height: 400px;
            border: 3px solid #2d3748;
            border-radius: 8px;
            margin: 20px 0;
            background: #f5f5f0;
            overflow: hidden;
        }

        .background-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .knife-line {
            stroke: #dc3545;
            stroke-width: 4;
            stroke-dasharray: 10,5;
            z-index: 5;
        }

            .knife-line.left-knife {
                stroke: #28a745;
            }

        .piece-overlay {
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 3;
        }

            .piece-overlay.selected {
                fill-opacity: 0.5 !important;
                stroke-width: 6 !important;
            }

        .button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            margin: 5px;
            transition: background 0.2s ease;
        }

            .button:hover:not(:disabled) {
                background: #2c5282;
            }

            .button:disabled {
                background: #a0aec0;
                cursor: not-allowed;
            }

            .button.danger {
                background: #e53e3e;
            }

                .button.danger:hover:not(:disabled) {
                    background: #c53030;
                }

        .instructions {
            background: #ebf8ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3182ce;
            margin: 20px 0;
        }

        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .player-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .player-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

            .player-card.active {
                border-color: #3182ce;
                background: #ebf8ff;
            }

        .color-legend {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
            padding: 10px;
            background: #ffffff;
            border-radius: 6px;
        }

        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            text-align: center;
        }

        .color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        .valuation-input {
            width: 35px;
            padding: 2px 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            text-align: center;
            font-size: 11px;
        }

        .utility-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }

        .utility-fill {
            height: 100%;
            background: #3182ce;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .utility-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #2d3748;
        }

        .current-values {
            background: #f0f4f7;
            padding: 8px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 13px;
        }

        .player-card.invalid {
            border-color: #e53e3e !important;
            background: #fff5f5 !important;
        }

        .validation-indicator {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="simulation-container">
        <div class="step-indicator" id="stepIndicator">
            Phase 1: Single knife moving across the cake
        </div>

        <div class="phase-indicator" id="phaseIndicator">
            Waiting for either player to call "STOP!" when they believe the left piece equals exactly 50%
        </div>

        <div class="instructions" id="instructions">
            <strong>Instructions:</strong> Watch the knife move across the cake. Either player can call "STOP!" when they think the left piece has exactly 50% value according to their preferences.
        </div>

        <div class="game-area" id="gameArea">
            <svg class="background-svg" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet">
                <!-- Blue region (top) -->
                <polygon points="0,0 600,0 600,150 0,150" fill="#0066ff" stroke="#2d3748" stroke-width="2" />
                <text x="300" y="80" text-anchor="middle" font-size="32" font-weight="bold" fill="white">Blue</text>

                <!-- Red region (top right) -->
                <polygon points="600,0 800,0 800,250 600,250" fill="#ff3366" stroke="#2d3748" stroke-width="2" />
                <text x="700" y="125" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Red</text>

                <!-- Orange region (right) -->
                <polygon points="600,250 800,250 800,350 600,350" fill="#ff6600" stroke="#2d3748" stroke-width="2" />
                <text x="700" y="310" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Orange</text>

                <!-- Purple region (bottom) -->
                <polygon points="150,350 800,350 800,400 150,400" fill="#9966ff" stroke="#2d3748" stroke-width="2" />
                <text x="500" y="380" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Purple</text>

                <!-- Pink region (bottom left) -->
                <polygon points="0,150 150,150 150,400 0,400" fill="#ff66ff" stroke="#2d3748" stroke-width="2" />
                <text x="80" y="280" text-anchor="middle" font-size="24" font-weight="bold" fill="white">Pink</text>

                <!-- Green region (center) -->
                <polygon points="150,150 600,150 600,350 150,350" fill="#3f9633" stroke="#2d3748" stroke-width="2" />
                <text x="380" y="260" text-anchor="middle" font-size="32" font-weight="bold" fill="white">Green</text>

                <!-- Moving knife -->
                <line id="movingKnife" x1="0" y1="0" x2="0" y2="400" class="knife-line" />

                <!-- Second knife (hidden initially) -->
                <line id="leftKnife" x1="0" y1="0" x2="0" y2="400" class="knife-line left-knife" style="display: none;" />

                <!-- Piece overlays for selection -->
                <rect id="leftPiece" x="0" y="0" width="400" height="400"
                      fill="rgba(49,130,206,0.2)" stroke="#3182ce" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
                <rect id="middlePiece" x="200" y="0" width="200" height="400"
                      fill="rgba(255,193,7,0.2)" stroke="#ffc107" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
                <rect id="rightPiece" x="400" y="0" width="400" height="400"
                      fill="rgba(72,187,120,0.2)" stroke="#38a169" stroke-width="3"
                      style="display: none;" class="piece-overlay" />
            </svg>
        </div>

        <div class="animation-controls">
            <button id="startButton" class="button">Start Animation</button>
            <button id="pauseButton" class="button" style="display: none;">Pause</button>
            <button id="player1StopButton" class="button danger" style="display: none;">Player 1: STOP!</button>
            <button id="player2StopButton" class="button danger" style="display: none;">Player 2: STOP!</button>
        </div>

        <div class="player-info">
            <div class="player-card" id="player1Card">
                <h3>Player 1</h3>
                <div class="color-legend">
                    <div class="color-item">
                        <div class="color-swatch" style="background: #0066ff;"></div>
                        <span>Blue: <input type="number" class="valuation-input" id="p1-blue" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff3366;"></div>
                        <span>Red: <input type="number" class="valuation-input" id="p1-red" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #3f9633;"></div>
                        <span>Green: <input type="number" class="valuation-input" id="p1-green" value="25" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff6600;"></div>
                        <span>Orange: <input type="number" class="valuation-input" id="p1-orange" value="10" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff66ff;"></div>
                        <span>Pink: <input type="number" class="valuation-input" id="p1-pink" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #9966ff;"></div>
                        <span>Purple: <input type="number" class="valuation-input" id="p1-purple" value="15" min="0" max="100">pts</span>
                    </div>
                </div>
                <div class="utility-bar">
                    <div class="utility-fill" id="p1-utility-fill"></div>
                    <div class="utility-text" id="p1-utility-text">0%</div>
                </div>
                <div class="current-values" id="p1-values">
                    <div><strong>Current Piece Value:</strong></div>
                    <div id="player1Value">Left: 0.0</div>
                </div>
            </div>

            <div class="player-card" id="player2Card">
                <h3>Player 2</h3>
                <div class="color-legend">
                    <div class="color-item">
                        <div class="color-swatch" style="background: #0066ff;"></div>
                        <span>Blue: <input type="number" class="valuation-input" id="p2-blue" value="15" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff3366;"></div>
                        <span>Red: <input type="number" class="valuation-input" id="p2-red" value="25" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #3f9633;"></div>
                        <span>Green: <input type="number" class="valuation-input" id="p2-green" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff6600;"></div>
                        <span>Orange: <input type="number" class="valuation-input" id="p2-orange" value="20" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #ff66ff;"></div>
                        <span>Pink: <input type="number" class="valuation-input" id="p2-pink" value="10" min="0" max="100">pts</span>
                    </div>
                    <div class="color-item">
                        <div class="color-swatch" style="background: #9966ff;"></div>
                        <span>Purple: <input type="number" class="valuation-input" id="p2-purple" value="10" min="0" max="100">pts</span>
                    </div>
                </div>
                <div class="utility-bar">
                    <div class="utility-fill" id="p2-utility-fill"></div>
                    <div class="utility-text" id="p2-utility-text">0%</div>
                </div>
                <div class="current-values" id="p2-values">
                    <div><strong>Current Piece Value:</strong></div>
                    <div id="player2Value">Left: 0.0</div>
                </div>
            </div>
        </div>

        <div style="text-align: center; margin: 20px 0;">
            <button id="resetButton" class="button">Reset Demo</button>
        </div>
    </div>

    <script>
        // Game state initialization
        let gameState = {
            phase: 1,
            isAnimating: false,
            isPaused: false,
            stopPosition: null,
            leftKnifePosition: 0,
            rightKnifePosition: 0,
            controllingPlayer: null,
            animationSpeed: 0.5,
            animationId: null,
            targetMiddleValue: null
        };

        const colorValues = {
            player1: { blue: 20, red: 15, green: 25, orange: 10, pink: 15, purple: 15 },
            player2: { blue: 15, red: 25, green: 20, orange: 20, pink: 10, purple: 10 }
        };

        const regions = {
            blue: { x1: 0, y1: 0, x2: 600, y2: 150 },
            red: { x1: 600, y1: 0, x2: 800, y2: 250 },
            orange: { x1: 600, y1: 250, x2: 800, y2: 350 },
            purple: { x1: 150, y1: 350, x2: 800, y2: 400 },
            pink: { x1: 0, y1: 150, x2: 150, y2: 400 },
            green: { x1: 150, y1: 150, x2: 600, y2: 350 }
        };

        // Core calculation functions
        function calculateRegionValues(cutX) {
            const leftValues = {};
            const rightValues = {};

            // For each color region, calculate 2D intersection
            for (const [color, bounds] of Object.entries(regions)) {
                const totalArea = (bounds.x2 - bounds.x1) * (bounds.y2 - bounds.y1);

                if (cutX <= bounds.x1) {
                    // Cut is entirely to the left, region is entirely in the right
                    leftValues[color] = 0;
                    rightValues[color] = 100;
                } else if (cutX >= bounds.x2) {
                    // Cut is entirely to the right, region is entirely in the left
                    leftValues[color] = 100;
                    rightValues[color] = 0;
                } else {
                    // Cut intersects the region
                    const leftArea = (cutX - bounds.x1) * (bounds.y2 - bounds.y1);
                    const leftPercent = (leftArea / totalArea) * 100;
                    leftValues[color] = leftPercent;
                    rightValues[color] = 100 - leftPercent;
                }
            }

            return { left: leftValues, right: rightValues };
        }

        // given a region value, determine how much a specific player values it
        function calculatePlayerValue(regionValues, player) {
            let total = 0;
            const prefs = colorValues[player];

            for (const [color, amount] of Object.entries(regionValues)) {
                total += (amount / 100) * prefs[color];
            }

            return total;
        }

        function validateConstraintPossible(targetValue, player, leftPos) {
            // Check if target value is reasonable
            if (targetValue < 0 || targetValue > 100) {
                return false;
            }

            // Test if we can achieve this value with any right position
            const testRight1 = findRightKnifePosition(leftPos, targetValue, player);
            const testMiddle = calculateMiddleRegionValues(leftPos, testRight1);
            const actualValue = calculatePlayerValue(testMiddle, player);

            // If we're within reasonable tolerance, it's possible
            return Math.abs(actualValue - targetValue) < 5; // 5% tolerance
        }

        // Utility and validation functions
        function updateColorValues() {
            colorValues.player1 = {
                blue: parseInt(document.getElementById('p1-blue').value) || 0,
                red: parseInt(document.getElementById('p1-red').value) || 0,
                green: parseInt(document.getElementById('p1-green').value) || 0,
                orange: parseInt(document.getElementById('p1-orange').value) || 0,
                pink: parseInt(document.getElementById('p1-pink').value) || 0,
                purple: parseInt(document.getElementById('p1-purple').value) || 0
            };

            colorValues.player2 = {
                blue: parseInt(document.getElementById('p2-blue').value) || 0,
                red: parseInt(document.getElementById('p2-red').value) || 0,
                green: parseInt(document.getElementById('p2-green').value) || 0,
                orange: parseInt(document.getElementById('p2-orange').value) || 0,
                pink: parseInt(document.getElementById('p2-pink').value) || 0,
                purple: parseInt(document.getElementById('p2-purple').value) || 0
            };
        }

        function updateValidationStatus() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            // Update or create validation indicators
            updatePlayerValidation('player1', p1Total);
            updatePlayerValidation('player2', p2Total);
        }

        function updatePlayerValidation(player, total) {
            const playerCard = document.getElementById(`${player}Card`);
            const cardNumber = player === 'player1' ? '1' : '2';

            // Remove existing validation indicator
            const existingIndicator = playerCard.querySelector('.validation-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Create new validation indicator
            const indicator = document.createElement('div');
            indicator.className = 'validation-indicator';
            indicator.style.cssText = `
                margin: 8px 0;
                padding: 6px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                text-align: center;
            `;

            if (total === 100) {
                indicator.textContent = `✓ Total: ${total} points`;
                indicator.style.background = '#f0fff4';
                indicator.style.color = '#38a169';
                indicator.style.border = '1px solid #68d391';
                playerCard.classList.remove('invalid');
            } else {
                indicator.textContent = `⚠ Total: ${total} points (needs 100)`;
                indicator.style.background = '#fff5f5';
                indicator.style.color = '#e53e3e';
                indicator.style.border = '1px solid #fc8181';
                playerCard.classList.add('invalid');
            }

            // Insert after the color legend
            const colorLegend = playerCard.querySelector('.color-legend');
            colorLegend.insertAdjacentElement('afterend', indicator);
        }

        function validateTotals() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);
            return p1Total === 100 && p2Total === 100;
        }

        function updateUtilityBars(p1Value, p2Value) {
            const p1Fill = document.getElementById('p1-utility-fill');
            const p1Text = document.getElementById('p1-utility-text');
            const p2Fill = document.getElementById('p2-utility-fill');
            const p2Text = document.getElementById('p2-utility-text');

            p1Fill.style.width = `${p1Value}%`;
            p1Text.textContent = `${Math.round(p1Value)}%`;

            p2Fill.style.width = `${p2Value}%`;
            p2Text.textContent = `${Math.round(p2Value)}%`;
        }

        function updateStartButtonState() {
            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            const startButton = document.getElementById('startButton');
            const isValid = p1Total === 100 && p2Total === 100;

            startButton.disabled = !isValid;
            startButton.textContent = isValid ? 'Start Animation' : 'Fix Valuations First';
        }

        function handleValuationChange() {
            updateColorValues();
            updateValidationStatus();
            updateStartButtonState();

            if (gameState.phase === 1 && gameState.isAnimating) {
                updateKnifePosition(gameState.rightKnifePosition);
            }
        }

        // Animation functions

        // update the position of a knife given its current position
        // update the position of a knife given its current position
        function updateKnifePosition(position) {
            const knife = document.getElementById('movingKnife');
            knife.setAttribute('x1', position);
            knife.setAttribute('x2', position);

            // Calculate and update values
            const regionValues = calculateRegionValues(position);
            const p1Left = calculatePlayerValue(regionValues.left, 'player1');
            const p2Left = calculatePlayerValue(regionValues.left, 'player2');

            document.getElementById('player1Value').textContent = `Left: ${Math.round(p1Left)}`;
            document.getElementById('player2Value').textContent = `Left: ${Math.round(p2Left)}`;

            updateUtilityBars(p1Left, p2Left);
        }

        // Update knife positions in Phase 2
        function updateKnifePositions() {
            const leftKnife = document.getElementById('leftKnife');
            const rightKnife = document.getElementById('movingKnife');

            leftKnife.setAttribute('x1', gameState.leftKnifePosition);
            leftKnife.setAttribute('x2', gameState.leftKnifePosition);
            rightKnife.setAttribute('x1', gameState.rightKnifePosition);
            rightKnife.setAttribute('x2', gameState.rightKnifePosition);
        }

        // Update value displays for Phase 2
        function updateValueDisplays() {
            const middleValues = calculateMiddleRegionValues(gameState.leftKnifePosition, gameState.rightKnifePosition);
            const p1Middle = calculatePlayerValue(middleValues, 'player1');
            const p2Middle = calculatePlayerValue(middleValues, 'player2');

            document.getElementById('player1Value').textContent = `Middle: ${Math.round(p1Middle)}`;
            document.getElementById('player2Value').textContent = `Middle: ${Math.round(p2Middle)}`;

            updateUtilityBars(p1Middle, p2Middle);
        }

        function showStopPosition() {
            // Add a visual indicator for where the left knife needs to reach
            const svg = document.querySelector('.background-svg');

            // Remove existing indicator if present
            const existingIndicator = document.getElementById('stopPositionIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }

            // Add new indicator
            const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            indicator.setAttribute('id', 'stopPositionIndicator');
            indicator.setAttribute('x1', gameState.stopPosition);
            indicator.setAttribute('y1', 0);
            indicator.setAttribute('x2', gameState.stopPosition);
            indicator.setAttribute('y2', 400);
            indicator.setAttribute('stroke', '#ffa500');
            indicator.setAttribute('stroke-width', '3');
            indicator.setAttribute('stroke-dasharray', '5,5');
            indicator.setAttribute('opacity', '0.7');

            svg.appendChild(indicator);
        }

        function startAnimation() {
            updateColorValues();

            const p1Total = Object.values(colorValues.player1).reduce((a, b) => a + b, 0);
            const p2Total = Object.values(colorValues.player2).reduce((a, b) => a + b, 0);

            if (p1Total !== 100 || p2Total !== 100) {
                alert(`Valuation totals must equal 100 points each!\n\nPlayer 1 total: ${p1Total}\nPlayer 2 total: ${p2Total}\n\nPlease adjust the values.`);
                return;
            }

            gameState.isAnimating = true;
            gameState.phase = 1;
            gameState.rightKnifePosition = 0;

            document.getElementById('startButton').style.display = 'none';
            document.getElementById('pauseButton').style.display = 'inline-block';
            document.getElementById('player1StopButton').style.display = 'inline-block';
            document.getElementById('player2StopButton').style.display = 'inline-block';

            animateKnife();
        }

        function animateKnife() {
            if (!gameState.isAnimating || gameState.isPaused) return;

            // Calculate current values for both players
            const regionValues = calculateRegionValues(gameState.rightKnifePosition);
            const p1Left = calculatePlayerValue(regionValues.left, 'player1');
            const p2Left = calculatePlayerValue(regionValues.left, 'player2');

            // Calculate how close each player is to 50%
            const p1Distance = Math.abs(p1Left - 50);
            const p2Distance = Math.abs(p2Left - 50);

            // Use the minimum distance (closest player to 50%)
            const minDistance = Math.min(p1Distance, p2Distance);

            // Calculate speed multiplier based on distance
            // When very close (distance < 2): slow down to 0.1x speed
            // When far (distance > 20): speed up to 2x speed
            // Linear interpolation between these points
            let speedMultiplier;
            if (minDistance < 2) {
                // Very close to 50% - slow way down
                speedMultiplier = 0.1 + (minDistance / 2) * 0.4; // 0.1x to 0.5x speed
            } else if (minDistance < 10) {
                // Somewhat close - moderate speed
                speedMultiplier = 0.5 + ((minDistance - 2) / 8) * 0.5; // 0.5x to 1.0x speed
            } else if (minDistance < 20) {
                // Not close - normal to fast speed
                speedMultiplier = 1.0 + ((minDistance - 10) / 10) * 1.0; // 1.0x to 2.0x speed
            } else {
                // Very far - maximum speed
                speedMultiplier = 2.0;
            }

            // Apply the dynamic speed
            const dynamicSpeed = gameState.animationSpeed * 0.5 * speedMultiplier;
            gameState.rightKnifePosition += dynamicSpeed;

            if (gameState.rightKnifePosition >= 800) {
                gameState.rightKnifePosition = 0; // Reset to start
            }

            updateKnifePosition(gameState.rightKnifePosition);

            gameState.animationId = requestAnimationFrame(animateKnife);
        }

        function pauseAnimation() {
            gameState.isPaused = !gameState.isPaused;
            const pauseBtn = document.getElementById('pauseButton');

            if (gameState.isPaused) {
                pauseBtn.textContent = 'Resume';
            } else {
                pauseBtn.textContent = 'Pause';
                animateKnife();
            }
        }

        function calculateMiddleRegionValues(leftCut, rightCut) {
            const middleValues = {};

            for (const [color, bounds] of Object.entries(regions)) {
                const totalArea = (bounds.x2 - bounds.x1) * (bounds.y2 - bounds.y1);

                // Find the intersection of the middle section with this region
                const leftBound = Math.max(bounds.x1, leftCut);
                const rightBound = Math.min(bounds.x2, rightCut);

                if (rightBound > leftBound) {
                    const middleArea = (rightBound - leftBound) * (bounds.y2 - bounds.y1);
                    middleValues[color] = (middleArea / totalArea) * 100;
                } else {
                    middleValues[color] = 0;
                }
            }

            return middleValues;
        }

        function findRightKnifePosition(leftPos, targetValue, player) {
            // Validate inputs
            if (leftPos < 0 || leftPos > 800 || targetValue < 0 || targetValue > 100) {
                console.warn(`Invalid inputs: leftPos=${leftPos}, targetValue=${targetValue}`);
                return Math.min(leftPos + 100, 800);
            }

            let low = leftPos + 1; // Ensure some middle section exists
            let high = 800;
            const tolerance = 0.5; // Increased tolerance for edge cases
            let iterations = 0;
            const maxIterations = 200; // Increased iterations

            while (high - low > 1 && iterations < maxIterations) {
                const mid = (low + high) / 2;
                const middleValues = calculateMiddleRegionValues(leftPos, mid);
                const currentValue = calculatePlayerValue(middleValues, player);

                if (Math.abs(currentValue - targetValue) < tolerance) {
                    return mid;
                }

                if (currentValue < targetValue) {
                    low = mid;
                } else {
                    high = mid;
                }
                iterations++;
            }

            // If no exact solution found, return best approximation
            const finalPos = (low + high) / 2;

            // Validate the result makes sense
            if (finalPos <= leftPos || finalPos > 800) {
                console.warn(`Binary search failed for leftPos=${leftPos}, targetValue=${targetValue}. Using fallback.`);
                return Math.min(leftPos + 100, 800);
            }

            return finalPos;
        }

        function stopPhase1(player) {
            gameState.isAnimating = false;
            gameState.controllingPlayer = player;
            gameState.stopPosition = gameState.rightKnifePosition;

            // Calculate the value to the left of the cut for the controlling player
            const regionValues = calculateRegionValues(gameState.rightKnifePosition);
            const controllingPlayerKey = `player${player}`;
            gameState.targetMiddleValue = calculatePlayerValue(regionValues.left, controllingPlayerKey);

            gameState.phase = 2;

            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }

            document.getElementById('pauseButton').style.display = 'none';
            document.getElementById('player1StopButton').style.display = 'none';
            document.getElementById('player2StopButton').style.display = 'none';

            document.getElementById('stepIndicator').textContent = 'Phase 2: Dual knife movement with value constraint';
            document.getElementById('phaseIndicator').textContent =
                `Player ${player} controls both knives. Left knife moves toward position ${Math.round(gameState.stopPosition)}, maintaining exactly ${Math.round(gameState.targetMiddleValue)} value in middle piece`;

            startPhase2();
        }

        function startPhase2() {
            // Show both knives
            const leftKnife = document.getElementById('leftKnife');
            leftKnife.style.display = 'block';

            showStopPosition();

            document.getElementById('instructions').innerHTML =
                '<strong>Phase 2:</strong> The controlling player\'s knives move automatically. The left knife (green) must reach the orange dashed line by the time the right knife (red) reaches the end, while maintaining the exact middle piece value.';

            // Initialize positions - left knife starts at beginning
            gameState.leftKnifePosition = 0;

            // Calculate initial right knife position to maintain the target value
            // Calculate initial right knife position to maintain the target value
            const controllingPlayerKey = `player${gameState.controllingPlayer}`;

            // Validate that the constraint is achievable
            if (!validateConstraintPossible(gameState.targetMiddleValue, controllingPlayerKey, gameState.leftKnifePosition)) {
                console.warn(`Target value ${gameState.targetMiddleValue} may not be perfectly achievable. Proceeding with best approximation.`);
            }

            gameState.rightKnifePosition = findRightKnifePosition(
                gameState.leftKnifePosition,
                gameState.targetMiddleValue,
                controllingPlayerKey
            );

            // Ensure valid positioning
            if (gameState.rightKnifePosition <= gameState.leftKnifePosition) {
                gameState.rightKnifePosition = gameState.leftKnifePosition + 50;
            }

            leftKnife.setAttribute('x1', gameState.leftKnifePosition);
            leftKnife.setAttribute('x2', gameState.leftKnifePosition);

            // Update knife positions
            updateKnifePositions();

            // Add stop button for the other player
            const otherPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            const stopButton = document.createElement('button');
            stopButton.textContent = `Player ${otherPlayer}: STOP!`;
            stopButton.className = 'button danger';
            stopButton.onclick = () => startPhase3();

            document.querySelector('.animation-controls').appendChild(stopButton);

            // Start dual knife animation
            setTimeout(() => {
                gameState.isAnimating = true;
                animateDualKnives();
            }, 1000);
        }

        function findLeftKnifePosition(rightPos, targetValue, player) {
            let low = 0;
            let high = rightPos;
            const tolerance = 0.01;

            while (high - low > 0.1) {
                const mid = (low + high) / 2;
                const middleValues = calculateMiddleRegionValues(mid, rightPos);
                const currentValue = calculatePlayerValue(middleValues, player);

                if (Math.abs(currentValue - targetValue) < tolerance) {
                    return mid;
                }

                if (currentValue < targetValue) {
                    high = mid;
                } else {
                    low = mid;
                }
            }

            return (low + high) / 2;
        }

        function animateDualKnives() {
            if (!gameState.isAnimating || gameState.isPaused) return;

            const speed = gameState.animationSpeed * 0.3;
            const controllingPlayerKey = `player${gameState.controllingPlayer}`;

            // Calculate targets
            const leftKnifeTarget = gameState.stopPosition; // Must reach original stop position
            const rightKnifeTarget = 800; // Must reach end of cake

            // Calculate remaining distances
            const leftRemaining = leftKnifeTarget - gameState.leftKnifePosition;
            const rightRemaining = rightKnifeTarget - gameState.rightKnifePosition;

            // Check if right knife has reached the end - this ends the phase
            if (rightRemaining <= 0) {
                // Right knife reached end, reset both and start over
                gameState.leftKnifePosition = 0;
                gameState.rightKnifePosition = findRightKnifePosition(0, gameState.targetMiddleValue, controllingPlayerKey);

                // Validate reset position
                if (gameState.rightKnifePosition <= 0 || gameState.rightKnifePosition > 800) {
                    gameState.rightKnifePosition = 100;
                }
            } else {
                // Move left knife toward stop position (but don't go past it)
                if (leftRemaining > 0) {
                    const leftStep = Math.min(speed, leftRemaining);
                    gameState.leftKnifePosition += leftStep;
                }
                // If leftRemaining <= 0, left knife stays at target position

                // Always try to move right knife forward
                const rightStep = speed;
                let newRightPosition = gameState.rightKnifePosition + rightStep;

                // Calculate required right position to maintain constraint
                let requiredRightPosition = findRightKnifePosition(
                    gameState.leftKnifePosition,
                    gameState.targetMiddleValue,
                    controllingPlayerKey
                );

                // Use whichever is further right: the natural progression or constraint requirement
                // This allows right knife to continue moving even when left knife is stuck
                const finalRightPosition = Math.max(newRightPosition, requiredRightPosition);

                // Check if final position is valid
                if (finalRightPosition > gameState.leftKnifePosition && finalRightPosition <= 800) {
                    gameState.rightKnifePosition = finalRightPosition;
                } else if (finalRightPosition > 800) {
                    // Right knife would go past end, so it's reached the target
                    gameState.rightKnifePosition = 800;
                } else {
                    // Something went wrong, reset
                    gameState.leftKnifePosition = 0;
                    gameState.rightKnifePosition = findRightKnifePosition(0, gameState.targetMiddleValue, controllingPlayerKey);

                    if (gameState.rightKnifePosition <= 0) {
                        gameState.rightKnifePosition = 100;
                    }
                }
            }

            // Update visual positions and displays
            updateKnifePositions();
            updateValueDisplays();

            gameState.animationId = requestAnimationFrame(animateDualKnives);
        }

        function startPhase3() {
            gameState.isAnimating = false;
            gameState.phase = 3;

            if (gameState.animationId) {
                cancelAnimationFrame(gameState.animationId);
            }

            document.getElementById('stepIndicator').textContent = 'Phase 3: Random Assignment';

            const choosingPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            document.getElementById('phaseIndicator').textContent = `Randomly assigning pieces...`;
            document.getElementById('instructions').innerHTML = '<strong>Random Assignment:</strong> The pieces will be randomly assigned to ensure fairness.';

            // Show piece overlays for visualization
            const leftPiece = document.getElementById('leftPiece');
            const middlePiece = document.getElementById('middlePiece');
            const rightPiece = document.getElementById('rightPiece');

            leftPiece.setAttribute('width', gameState.leftKnifePosition);
            leftPiece.style.display = 'block';

            middlePiece.setAttribute('x', gameState.leftKnifePosition);
            middlePiece.setAttribute('width', gameState.rightKnifePosition - gameState.leftKnifePosition);
            middlePiece.style.display = 'block';

            rightPiece.setAttribute('x', gameState.rightKnifePosition);
            rightPiece.setAttribute('width', 800 - gameState.rightKnifePosition);
            rightPiece.style.display = 'block';

            // Remove click handlers
            leftPiece.onclick = null;
            middlePiece.onclick = null;
            rightPiece.onclick = null;

            // Randomly assign after a brief delay
            setTimeout(() => {
                const randomChoice = Math.random() < 0.5 ? 'inside' : 'outside';
                performRandomAssignment(randomChoice, choosingPlayer);
            }, 2000);
        }

        function performRandomAssignment(randomChoice, choosingPlayer) {
            // Highlight the randomly selected piece briefly
            const selectedOverlay = randomChoice === 'inside' ?
                document.getElementById('middlePiece') :
                [document.getElementById('leftPiece'), document.getElementById('rightPiece')];

            if (Array.isArray(selectedOverlay)) {
                selectedOverlay.forEach(piece => {
                    piece.style.stroke = '#ffd700';
                    piece.style.strokeWidth = '6';
                    piece.style.fillOpacity = '0.6';
                });
            } else {
                selectedOverlay.style.stroke = '#ffd700';
                selectedOverlay.style.strokeWidth = '6';
                selectedOverlay.style.fillOpacity = '0.6';
            }

            // Update phase indicator to show the result
            document.getElementById('phaseIndicator').textContent =
                `Random assignment complete! Player ${choosingPlayer} received the ${randomChoice} piece.`;

            // Show results after brief highlight
            setTimeout(() => {
                performFinalCalculation(randomChoice, choosingPlayer);
            }, 1500);
        }

        function performFinalCalculation(selectedPiece, choosingPlayer) {
            gameState.isAnimating = false;

            // Calculate final values for the two actual pieces
            const middleValues = calculateMiddleRegionValues(gameState.leftKnifePosition, gameState.rightKnifePosition);

            // Calculate outside piece (left + right combined)
            const leftValues = calculateRegionValues(gameState.leftKnifePosition).left;
            const rightValues = calculateRegionValues(gameState.rightKnifePosition).right;

            // Combine left and right for outside piece
            const outsideValues = {};
            for (const color in leftValues) {
                outsideValues[color] = leftValues[color] + rightValues[color];
            }

            const p1Inside = calculatePlayerValue(middleValues, 'player1');
            const p1Outside = calculatePlayerValue(outsideValues, 'player1');

            const p2Inside = calculatePlayerValue(middleValues, 'player2');
            const p2Outside = calculatePlayerValue(outsideValues, 'player2');

            const controllingPlayer = gameState.controllingPlayer;

            // Show results
            showResults(selectedPiece, choosingPlayer, controllingPlayer, {
                inside: { p1: p1Inside, p2: p2Inside },
                outside: { p1: p1Outside, p2: p2Outside }
            });
        }

        function selectPiece(piece) {
            gameState.isAnimating = false;

            // Calculate final values for the two actual pieces
            const middleValues = calculateMiddleRegionValues(gameState.leftKnifePosition, gameState.rightKnifePosition);

            // Calculate outside piece (left + right combined)
            const leftValues = calculateRegionValues(gameState.leftKnifePosition).left;
            const rightValues = calculateRegionValues(gameState.rightKnifePosition).right;

            // Combine left and right for outside piece
            const outsideValues = {};
            for (const color in leftValues) {
                outsideValues[color] = leftValues[color] + rightValues[color];
            }

            const p1Inside = calculatePlayerValue(middleValues, 'player1');
            const p1Outside = calculatePlayerValue(outsideValues, 'player1');

            const p2Inside = calculatePlayerValue(middleValues, 'player2');
            const p2Outside = calculatePlayerValue(outsideValues, 'player2');

            // Determine what the choosing player selected
            const choosingPlayer = gameState.controllingPlayer === 1 ? 2 : 1;
            const controllingPlayer = gameState.controllingPlayer;

            // Convert click to actual choice (left/right clicks both mean "outside")
            const actualChoice = piece === 'middle' ? 'inside' : 'outside';

            // Show results
            showResults(actualChoice, choosingPlayer, controllingPlayer, {
                inside: { p1: p1Inside, p2: p2Inside },
                outside: { p1: p1Outside, p2: p2Outside }
            });
        }

        function showResults(selectedPiece, choosingPlayer, controllingPlayer, allValues) {
            // Hide the game area and show results
            document.getElementById('gameArea').style.display = 'none';
            document.querySelector('.animation-controls').style.display = 'none';

            // Create results display
            const resultsHTML = `
                <div id="resultsSection" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h2 style="text-align: center; color: #2d3748; margin-bottom: 20px;">Results</h2>
            
                    <div style="background: white; padding: 15px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #3182ce;">
                        <h3>Protocol Summary:</h3>
                        <p><strong>Phase 1:</strong> Player ${controllingPlayer} stopped the knife when they believed the left portion was worth exactly 50% to them.</p>
                        <p><strong>Phase 2:</strong> Player ${controllingPlayer} controlled both knives, maintaining their 50% value constraint in the middle piece.</p>
                        <p><strong>Phase 3:</strong> The pieces were <strong>randomly assigned</strong>. Player ${choosingPlayer} received the <strong>${selectedPiece} piece</strong>.</p>
                    </div>
            
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div style="background: white; padding: 20px; border-radius: 6px; text-align: center; ${selectedPiece === 'inside' ? 'border: 3px solid #3182ce;' : 'border: 1px solid #e2e8f0;'}">
                            <h4 style="color: #ffc107; margin-bottom: 15px;">Inside Piece (Middle)</h4>
                            <div style="background: #fff8e1; padding: 10px; border-radius: 4px; margin: 10px 0;">
                                <p style="margin: 5px 0;">Player 1 Value: <strong>${Math.round(allValues.inside.p1)}</strong> points</p>
                                <p style="margin: 5px 0;">Player 2 Value: <strong>${Math.round(allValues.inside.p2)}</strong> points</p>
                            </div>
                            ${selectedPiece === 'inside' ? '<p style="color: #3182ce; font-weight: bold; margin-top: 10px;">✓ SELECTED</p>' : ''}
                        </div>
                
                        <div style="background: white; padding: 20px; border-radius: 6px; text-align: center; ${selectedPiece === 'outside' ? 'border: 3px solid #3182ce;' : 'border: 1px solid #e2e8f0;'}">
                            <h4 style="color: #38a169; margin-bottom: 15px;">Outside Piece (Left + Right)</h4>
                            <div style="background: #f0fff4; padding: 10px; border-radius: 4px; margin: 10px 0;">
                                <p style="margin: 5px 0;">Player 1 Value: <strong>${Math.round(allValues.outside.p1)}</strong> points</p>
                                <p style="margin: 5px 0;">Player 2 Value: <strong>${Math.round(allValues.outside.p2)}</strong> points</p>
                            </div>
                            ${selectedPiece === 'outside' ? '<p style="color: #3182ce; font-weight: bold; margin-top: 10px;">✓ SELECTED</p>' : ''}
                        </div>
                    </div>
            
                    <div style="background: #ebf8ff; padding: 15px; border-radius: 6px; margin: 20px 0;">
                        <h3 style="color: #2d3748;">Random Assignment Result:</h3>
                        <p><strong>Player ${choosingPlayer}</strong> was randomly assigned the <strong>${selectedPiece}</strong> piece → <strong>${Math.round(choosingPlayer === 1 ? allValues[selectedPiece].p1 : allValues[selectedPiece].p2)} points</strong></p>
                        <p><strong>Player ${controllingPlayer}</strong> gets the remaining <strong>${selectedPiece === 'inside' ? 'outside' : 'inside'}</strong> piece → <strong>${Math.round(controllingPlayer === 1 ? allValues[selectedPiece === 'inside' ? 'outside' : 'inside'].p1 : allValues[selectedPiece === 'inside' ? 'outside' : 'inside'].p2)} points</strong></p>
                    </div>
                </div>
            `;

            // Insert results after the player info
            document.querySelector('.player-info').insertAdjacentHTML('afterend', resultsHTML);

            // Update step indicator
            document.getElementById('stepIndicator').textContent = 'Demo Complete - Results';
            document.getElementById('phaseIndicator').textContent = `Player ${choosingPlayer} selected the ${selectedPiece} piece. Fair division achieved!`;
        }

        function resetDemo() {
            location.reload();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {
            document.getElementById('startButton').addEventListener('click', startAnimation);
            document.getElementById('pauseButton').addEventListener('click', pauseAnimation);
            document.getElementById('player1StopButton').addEventListener('click', () => stopPhase1(1));
            document.getElementById('player2StopButton').addEventListener('click', () => stopPhase1(2));
            document.getElementById('resetButton').addEventListener('click', resetDemo);

            // Add event listeners for valuation inputs
            ['p1-blue', 'p1-red', 'p1-green', 'p1-orange', 'p1-pink', 'p1-purple',
                'p2-blue', 'p2-red', 'p2-green', 'p2-orange', 'p2-pink', 'p2-purple'].forEach(id => {
                    document.getElementById(id).addEventListener('input', handleValuationChange);
                });

            // Initialize values
            updateColorValues();
            updateValidationStatus();
            updateStartButtonState();
            updateKnifePosition(0);
        });
    </script>
</body>
</html>