<!-- _includes/foundations/proportionality_interactive_python.html -->
<div class="demo-section" id="proportionalityDemo">
    <h4>Interactive Visualization</h4>

    <div id="python-loading" style="display: block;">
        <div class="loading-spinner"> Loading Python environment... This may take a few seconds on first load.</div>
    </div>

    <div class="demo-explanation">
        <p>
            Visualize how different players value overlapping regions of a resource.
            Adjust the division to see if each player receives at least 1/n of their total valuation.
        </p>
    </div>

    <div class="demo-controls">
        <div class="control-group">
            <label class="control-label">Number of Players:</label>
            <div class="slider-container">
                <input type="range" id="propPlayerCount" class="demo-slider" min="2" max="4" value="3">
                <span id="propPlayerValue" class="value-display">3</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">Division Style:</label>
            <select id="propDivisionType" class="demo-select">
                <option value="vertical">Vertical Strips</option>
                <option value="horizontal">Horizontal Strips</option>
            </select>
        </div>

        <div class="control-group">
            <label class="control-label">Division Points:</label>
            <div id="propDivisionControls"></div>
        </div>

        <div class="threshold-info">
            Each player needs ≥ <span id="propThreshold">33.3%</span> of their valuation to be proportional
        </div>
    </div>

    <div class="visualization-container">
        <div id="propVisualization">
            <div class="placeholder-text">Visualization will appear here once Python loads...</div>
        </div>
    </div>

    <div id="propResults" class="results-container"></div>

    <div id="propSummary" class="summary-container">
        Adjust the controls above to explore different resource divisions and see how proportionality is affected.
    </div>
</div>

<!-- Load Pyodide -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>

<script type="text/javascript">
    let pyodide = null;
    let propViz = null;

    async function initializePyodide() {
        if (pyodide) return pyodide;

        const loadingEl = document.getElementById('python-loading');
        if (loadingEl) loadingEl.style.display = 'block';

        try {
            pyodide = await loadPyodide();
            await pyodide.loadPackage(['matplotlib', 'numpy']);

            // Set up matplotlib for web
            pyodide.runPython(`
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import io
import base64

def show_plot():
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png', bbox_inches='tight', dpi=100, facecolor='white')
    buffer.seek(0)
    img_str = base64.b64encode(buffer.getvalue()).decode()
    plt.close()
    return f'<img src="data:image/png;base64,{img_str}" style="max-width: 100%; height: auto;">'

plt.show = show_plot
        `);

            // Load the main Python class
            pyodide.runPython(`
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.colors import to_hex
import json

class ProportionalityVisualizer:
    def __init__(self):
        self.player_count = 3
        self.division_type = 'vertical'
        self.division_points = []
        self.colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b']
        self.player_names = ['Red', 'Blue', 'Green', 'Orange']
        self.players = []
        self.setup_players()
        self.setup_divisions()

    def setup_players(self):
        """Define preference patterns for each player"""
        self.players = []

        # Define overlapping preference patterns that create interesting scenarios
        patterns = [
            # Red: Top region + center area
            [
                {'type': 'rect', 'x': 10, 'y': 70, 'width': 80, 'height': 20, 'value': 60},
                {'type': 'rect', 'x': 20, 'y': 30, 'width': 60, 'height': 30, 'value': 40}
            ],
            # Blue: Left side + bottom right
            [
                {'type': 'rect', 'x': 5, 'y': 10, 'width': 30, 'height': 80, 'value': 70},
                {'type': 'rect', 'x': 60, 'y': 10, 'width': 30, 'height': 25, 'value': 30}
            ],
            # Green: Center + right edge
            [
                {'type': 'rect', 'x': 30, 'y': 40, 'width': 40, 'height': 30, 'value': 50},
                {'type': 'rect', 'x': 75, 'y': 20, 'width': 20, 'height': 60, 'value': 50}
            ],
            # Orange: Bottom band + top corner
            [
                {'type': 'rect', 'x': 10, 'y': 5, 'width': 80, 'height': 25, 'value': 55},
                {'type': 'rect', 'x': 70, 'y': 60, 'width': 25, 'height': 25, 'value': 45}
            ]
        ]

        for i in range(self.player_count):
            self.players.append({
                'name': self.player_names[i],
                'color': self.colors[i],
                'regions': patterns[i]
            })

    def setup_divisions(self):
        """Initialize division points"""
        self.division_points = []
        for i in range(self.player_count - 1):
            self.division_points.append(100 * (i + 1) / self.player_count)

    def calculate_overlap(self, allocation, region):
        """Calculate overlap between allocation and preference region"""
        left = max(allocation['x'], region['x'])
        right = min(allocation['x'] + allocation['width'], region['x'] + region['width'])
        top = max(allocation['y'], region['y'])
        bottom = min(allocation['y'] + allocation['height'], region['y'] + region['height'])

        if left < right and top < bottom:
            return (right - left) * (bottom - top)
        return 0

    def get_player_allocations(self):
        """Get current allocation based on division points"""
        allocations = []

        if self.division_type == 'vertical':
            prev_x = 0
            for i in range(self.player_count):
                next_x = self.division_points[i] if i < len(self.division_points) else 100
                allocations.append({
                    'x': prev_x, 'y': 0,
                    'width': next_x - prev_x, 'height': 100
                })
                prev_x = next_x
        else:  # horizontal
            prev_y = 0
            for i in range(self.player_count):
                next_y = self.division_points[i] if i < len(self.division_points) else 100
                allocations.append({
                    'x': 0, 'y': prev_y,
                    'width': 100, 'height': next_y - prev_y
                })
                prev_y = next_y

        return allocations

    def calculate_results(self):
        """Calculate proportionality results for all players"""
        allocations = self.get_player_allocations()
        results = []

        for i, player in enumerate(self.players):
            allocation = allocations[i]

            total_value = sum(region['value'] for region in player['regions'])

            received_value = 0
            for region in player['regions']:
                region_area = region['width'] * region['height']
                overlap = self.calculate_overlap(allocation, region)
                overlap_ratio = overlap / region_area if region_area > 0 else 0
                received_value += overlap_ratio * region['value']

            value_percentage = (received_value / total_value) * 100 if total_value > 0 else 0
            required_percentage = 100 / self.player_count
            is_proportional = value_percentage >= required_percentage - 1

            results.append({
                'player': player['name'],
                'received': value_percentage,
                'required': required_percentage,
                'proportional': is_proportional,
                'color': player['color']
            })

        return results

    def create_svg_visualization(self):
        """Create SVG visualization of the resource division"""
        allocations = self.get_player_allocations()

        # SVG dimensions
        width, height = 400, 300

        svg_parts = [f'<svg width="{width}" height="{height}" xmlns="http://www.w3.org/2000/svg" style="border: 1px solid #ddd; background: white;">']

        # Draw preference regions (dashed, transparent)
        for i, player in enumerate(self.players):
            for region in player['regions']:
                x = region['x'] * width / 100
                y = region['y'] * height / 100
                w = region['width'] * width / 100
                h = region['height'] * height / 100

                svg_parts.append(f'<rect x="{x}" y="{y}" width="{w}" height="{h}" '
                               f'fill="{player["color"]}" opacity="0.2" '
                               f'stroke="{player["color"]}" stroke-width="1" stroke-dasharray="5,5"/>')

        # Draw player allocations (solid)
        for i, player in enumerate(self.players):
            allocation = allocations[i]
            x = allocation['x'] * width / 100
            y = allocation['y'] * height / 100
            w = allocation['width'] * width / 100
            h = allocation['height'] * height / 100

            svg_parts.append(f'<rect x="{x}" y="{y}" width="{w}" height="{h}" '
                           f'fill="{player["color"]}" opacity="0.6" '
                           f'stroke="{player["color"]}" stroke-width="2"/>')

            # Add player label
            label_x = x + w / 2
            label_y = y + h / 2
            svg_parts.append(f'<text x="{label_x}" y="{label_y}" text-anchor="middle" '
                           f'dominant-baseline="middle" fill="white" font-weight="bold" '
                           f'font-size="14" stroke="black" stroke-width="0.5">{player["name"]}</text>')

        svg_parts.append('</svg>')
        return ''.join(svg_parts)

    def update_division_points(self, new_points):
        """Update division points"""
        self.division_points = new_points.copy()

    def update(self):
        """Update the entire visualization"""
        try:
            # Update SVG visualization
            svg_content = self.create_svg_visualization()

            # Calculate results for HTML output
            results = self.calculate_results()

            # Return data for JavaScript to handle
            return {
                'svg': svg_content,
                'results': results,
                'proportional_count': sum(1 for r in results if r['proportional']),
                'total_count': len(results)
            }
        except Exception as e:
            print(f"Error in update: {e}")
            return {'error': str(e)}

# Create global instance
prop_viz = ProportionalityVisualizer()
        `);

            if (loadingEl) loadingEl.style.display = 'none';

            // Initialize everything - FIXED ORDER
            updateThreshold();
            updateDivisionControls();
            setupEventListeners();
            updateVisualization();

            console.log('Pyodide initialized successfully!');

        } catch (error) {
            console.error('Pyodide error:', error);
            if (loadingEl) {
                loadingEl.innerHTML = '<div style="color: red;">Error loading Python: ' + error.message + '</div>';
            }
        }
    }

    function updateVisualization() {
        if (!pyodide) return;

        try {
            const result = pyodide.runPython(`prop_viz.update()`);
            const data = result.toJs({ dict_converter: Object.fromEntries });

            if (data.error) {
                console.error('Python error:', data.error);
                return;
            }

            // Update SVG visualization
            const vizContainer = document.getElementById('propVisualization');
            if (vizContainer && data.svg) {
                vizContainer.innerHTML = data.svg;
            }

            // Update results
            updateResultsDisplay(data.results);

            // Update summary
            const summary = document.getElementById('propSummary');
            if (summary) {
                if (data.proportional_count === data.total_count) {
                    summary.innerHTML = `🎉 <strong>Perfect!</strong> All ${data.total_count} players receive at least their proportional share. This division satisfies the proportionality criterion.`;
                } else {
                    summary.innerHTML = `⚠️ <strong>Not Proportional:</strong> ${data.total_count - data.proportional_count} out of ${data.total_count} players receive less than their required share.`;
                }
            }
        } catch (error) {
            console.error('Visualization update error:', error);
        }
    }

    function updateResultsDisplay(results) {
        const container = document.getElementById('propResults');
        if (!container || !results) return;

        container.innerHTML = '';

        results.forEach(result => {
            const card = document.createElement('div');
            card.className = 'player-result-card';
            card.style.borderLeftColor = result.color;

            card.innerHTML = `
            <div class="player-name">${result.player}</div>
            <div class="player-stats">
                <div class="stat-item">
                    <div class="stat-value">${result.received.toFixed(1)}%</div>
                    <div class="stat-label">Received</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${result.required.toFixed(1)}%</div>
                    <div class="stat-label">Required</div>
                </div>
            </div>
            <div class="proportional-status ${result.proportional ? 'proportional-yes' : 'proportional-no'}">
                ${result.proportional ? '✓ Proportional' : '✗ Not Proportional'}
            </div>
        `;

            container.appendChild(card);
        });
    }

    function updateThreshold() {
        if (!pyodide) return;

        const playerCount = pyodide.runPython('prop_viz.player_count');
        const threshold = (100 / playerCount).toFixed(1);
        const thresholdElement = document.getElementById('propThreshold');
        if (thresholdElement) {
            thresholdElement.textContent = threshold + '%';
        }
    }

    function updateDivisionControls() {
        if (!pyodide) return;

        const container = document.getElementById('propDivisionControls');
        if (!container) return;

        const playerCount = pyodide.runPython('prop_viz.player_count');
        const divisionType = pyodide.runPython('prop_viz.division_type');
        const divisionPoints = pyodide.runPython('prop_viz.division_points').toJs();

        container.innerHTML = '';

        const numControls = playerCount - 1;
        for (let i = 0; i < numControls; i++) {
            const div = document.createElement('div');
            div.className = 'slider-container';

            const currentValue = divisionPoints[i] || (100 * (i + 1) / playerCount);

            div.innerHTML = `
            <label style="min-width: 80px; font-size: 0.9rem; color: var(--text-secondary);">
                ${divisionType === 'vertical' ? 'Vertical' : 'Horizontal'} ${i + 1}:
            </label>
            <input type="range" class="demo-slider division-point-slider" min="10" max="90" step="1"
                   value="${currentValue}" data-index="${i}">
            <span class="value-display">${currentValue.toFixed(0)}%</span>
        `;
            container.appendChild(div);
        }

        // Add event listeners to division sliders - FIXED
        addDivisionSliderListeners();
    }

    function addDivisionSliderListeners() {
        const sliders = document.querySelectorAll('.division-point-slider');

        sliders.forEach(slider => {
            slider.addEventListener('input', function () {
                const index = parseInt(this.dataset.index);
                let value = parseFloat(this.value);

                // Get current division points
                const currentPoints = pyodide.runPython('prop_viz.division_points').toJs();

                // Enforce ordering constraints
                const minValue = index > 0 ? currentPoints[index - 1] + 5 : 10;
                const maxValue = index < currentPoints.length - 1 ? currentPoints[index + 1] - 5 : 90;

                // Clamp value to valid range
                value = Math.max(minValue, Math.min(maxValue, value));
                this.value = value;

                // Update display
                this.nextElementSibling.textContent = value.toFixed(0) + '%';

                // Update Python
                pyodide.runPython(`prop_viz.division_points[${index}] = ${value}`);

                // Update visualization
                updateVisualization();
            });
        });
    }

    function setupEventListeners() {
        // Player count slider
        const playerSlider = document.getElementById('propPlayerCount');
        if (playerSlider) {
            playerSlider.addEventListener('input', function () {
                const count = parseInt(this.value);
                document.getElementById('propPlayerValue').textContent = count;

                pyodide.runPython(`
prop_viz.player_count = ${count}
prop_viz.setup_players()
prop_viz.setup_divisions()
            `);

                updateThreshold();
                updateDivisionControls();
                updateVisualization();
            });
        }

        // Division type dropdown
        const divisionSelect = document.getElementById('propDivisionType');
        if (divisionSelect) {
            divisionSelect.addEventListener('change', function () {
                const type = this.value;

                pyodide.runPython(`
prop_viz.division_type = '${type}'
prop_viz.setup_divisions()
            `);

                updateDivisionControls();
                updateVisualization();
            });
        }
    }

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        setTimeout(initializePyodide, 100);
    });
</script>

<style>
    :root {
        --text-primary: #1f2937;
        --text-secondary: #6b7280;
        --text-muted: #9ca3af;
        --border-light: #e5e7eb;
        --border-medium: #d1d5db;
        --light-blue: #eff6ff;
        --primary-blue: #3b82f6;
        --bg-white: #ffffff;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .demo-section {
        background: linear-gradient(135deg, #f8fafc, #ffffff);
        border: 1px solid var(--border-light);
        border-radius: 12px;
        padding: 2rem;
        margin: 2rem 0;
        box-shadow: var(--shadow-md);
        max-width: 1200px;
        margin: 0 auto;
    }

    h4 {
        color: var(--text-primary);
        margin-bottom: 1rem;
        font-weight: 600;
        font-size: 1.5rem;
    }

    .loading-spinner {
        text-align: center;
        padding: 2rem;
        color: var(--primary-blue);
        font-weight: 500;
        background: var(--light-blue);
        border-radius: 8px;
        margin: 1rem 0;
    }

    .demo-explanation {
        background: var(--light-blue);
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1.5rem;
        border-left: 3px solid var(--primary-blue);
    }

        .demo-explanation p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin: 0;
        }

    .demo-controls {
        background: var(--bg-white);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        border: 1px solid var(--border-light);
    }

    .control-group {
        margin-bottom: 1.5rem;
    }

    .control-label {
        display: block;
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: var(--text-primary);
        font-size: 0.95rem;
    }

    .slider-container {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.5rem;
    }

    .demo-slider {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: var(--border-medium);
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
    }

        .demo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
            transition: all 0.2s ease;
        }

            .demo-slider::-webkit-slider-thumb:hover {
                transform: scale(1.1);
            }

    .demo-select {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--border-medium);
        border-radius: 6px;
        background: var(--bg-white);
        font-size: 0.9rem;
        color: var(--text-primary);
    }

    .value-display {
        font-weight: 600;
        color: var(--primary-blue);
        min-width: 60px;
        text-align: right;
        font-size: 0.9rem;
        font-family: 'Courier New', monospace;
    }

    .threshold-info {
        background: var(--light-blue);
        padding: 0.75rem;
        border-radius: 6px;
        text-align: center;
        font-size: 0.9rem;
        color: var(--primary-blue);
        font-weight: 500;
    }

    .visualization-container {
        background: var(--bg-white);
        border-radius: 8px;
        padding: 1rem;
        margin: 1.5rem 0;
        border: 1px solid var(--border-light);
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .placeholder-text {
        color: var(--text-muted);
        font-style: italic;
        text-align: center;
    }

    .results-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
        margin: 1.5rem 0;
    }

    .player-result-card {
        background: var(--bg-white);
        border-radius: 8px;
        padding: 1.25rem;
        border-left: 4px solid var(--primary-blue);
        border: 1px solid var(--border-light);
        transition: all 0.2s ease;
    }

        .player-result-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

    .player-name {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.75rem;
        font-size: 1rem;
    }

    .player-stats {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.75rem;
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--primary-blue);
        font-family: 'Courier New', monospace;
    }

    .stat-label {
        font-size: 0.8rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .proportional-status {
        padding: 0.4rem 0.8rem;
        border-radius: 15px;
        font-weight: 600;
        font-size: 0.8rem;
        text-align: center;
        text-transform: uppercase;
    }

    .proportional-yes {
        background: linear-gradient(135deg, #d1fae5, #a7f3d0);
        color: #065f46;
    }

    .proportional-no {
        background: linear-gradient(135deg, #fecaca, #fca5a5);
        color: #991b1b;
    }

    .summary-container {
        background: var(--light-blue);
        padding: 1.25rem;
        border-radius: 8px;
        text-align: center;
        font-size: 0.95rem;
        color: var(--primary-blue);
        font-weight: 500;
        margin-top: 1.5rem;
    }

    @media (max-width: 768px) {
        .demo-section {
            padding: 1.5rem;
        }

        .results-container {
            grid-template-columns: 1fr;
        }

        .player-stats {
            flex-direction: column;
            gap: 0.5rem;
        }
    }
</style>