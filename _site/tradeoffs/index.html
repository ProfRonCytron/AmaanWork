<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Trade-offs | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main-backup.css">
    

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Property Trade-offs | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Property Trade-offs" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron" />
<meta property="og:description" content="Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron" />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/tradeoffs/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/tradeoffs/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Property Trade-offs" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron","headline":"Property Trade-offs","url":"http://localhost:4000/fair-division-algorithms/tradeoffs/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/analysis/">Analysis</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="page-header">
  <h1 class="page-title">Property Trade-offs</h1>
  <p class="page-description">Why you can't have it all: fundamental conflicts between fairness properties</p>
</div>

<div class="content-block">
  <h2>The Fundamental Tension</h2>
  <p>In fair division, as in life, you can't always have everything you want. Different fairness properties often conflict with each other, forcing algorithm designers to make difficult choices about which properties to prioritize.</p>
  <p>Understanding these trade-offs is crucial for selecting appropriate algorithms and setting realistic expectations for what fairness can achieve in practice.</p>
</div>

<div class="content-block">
  <h2>Major Trade-off Categories</h2>

  <div class="properties-grid">
    <div class="property-card">
      <h3>Fairness vs. Efficiency</h3>
      <p class="property-description">
        <strong>The Core Tension:</strong> Ensuring fairness often prevents achieving maximum total welfare.
      </p>

      <div class="proof-sketch">
        <p><strong>Classic Example:</strong> Two players, one cake. Player 1 loves chocolate and values the entire cake at 100. Player 2 is allergic to chocolate and values it at 0.</p>
        
        <p><strong>Pareto Efficient Solution:</strong> Give everything to Player 1 (total welfare = 100)</p>
        <p><strong>Fair Solution:</strong> Split 50-50 (total welfare = 50, but Player 2 gets proportional share)</p>
        
        <p><strong>Mathematical Formalization:</strong> Let $W = \sum_i v_i(\text{piece}_i)$ be total welfare. Pareto efficiency maximizes $W$, but fairness constraints like $v_i(\text{piece}_i) \geq \frac{1}{n} v_i(\text{total})$ can force $W$ to be suboptimal.</p>
      </div>
      
      <p><strong>Resolution Strategies:</strong> Weighted fairness, constrained efficiency, or lexicographic optimization.</p>
    </div>

    <div class="property-card">
      <h3>Strategy-Proofness vs. Optimality</h3>
      <p class="property-description">
        <strong>The Incentive Problem:</strong> Preventing manipulation often limits achievable outcomes.
      </p>
      
      <div class="proof-sketch">
        <p><strong>Intuition:</strong> To make an algorithm strategy-proof, you often have to "waste" some potential by not fully optimizing based on reported preferences, since those preferences might be lies.</p>
        
        <p><strong>Example:</strong> In second-price auctions, the winner pays the second-highest bid rather than their own bid. This ensures truthful bidding but doesn't extract maximum revenue.</p>
        
        <p><strong>Fair Division Context:</strong> Many optimal fair division procedures become manipulable when players can misreport preferences. Making them strategy-proof often requires suboptimal allocations.</p>
      </div>
      
      <p><strong>Common Approaches:</strong> Mechanism design theory, randomization, or restricted preference domains.</p>
    </div>

    <div class="property-card">
      <h3>Simplicity vs. Fairness</h3>
      <p class="property-description">
        <strong>Complexity Creep:</strong> Stronger fairness properties often require more complex algorithms.
      </p>
      
      <div class="proof-sketch">
        <p><strong>Progression Example:</strong></p>
        <ul>
          <li><strong>Proportional (2 players):</strong> Divide-and-Choose (2 queries, 2 steps)</li>
          <li><strong>Envy-free (2 players):</strong> Divide-and-Choose (same - coincidence!)</li>
          <li><strong>Envy-free (3 players):</strong> Selfridge-Conway (complex, multi-phase)</li>
          <li><strong>Envy-free (n players):</strong> No known bounded finite algorithm</li>
        </ul>
        
        <p><strong>Query Complexity Growth:</strong> Stronger fairness properties typically require more queries, making algorithms harder to implement and understand.</p>
      </div>
      
      <p><strong>Practical Impact:</strong> Simple algorithms are easier to explain, implement, and gain acceptance, even if they achieve weaker fairness.</p>
    </div>

    <div class="property-card">
      <h3>Precision vs. Computability</h3>
      <p class="property-description">
        <strong>The Discrete Barrier:</strong> Exact fairness often requires infinite precision.
      </p>
      
      <div class="proof-sketch">
        <p><strong>Exactness Challenge:</strong> Achieving perfect 50-50 splits requires finding cuts at positions that may be irrational numbers, requiring infinite precision to specify exactly.</p>
        
        <p><strong>Computational Reality:</strong> Real computers have finite precision, making truly exact algorithms impossible to implement.</p>
        
        <p><strong>Approximation Trade-off:</strong> $\epsilon$-fair algorithms achieve fairness within $\epsilon$ but require $O(\log(1/\epsilon))$ computational resources.</p>
      </div>
      
      <p><strong>Resolution:</strong> Accept approximation, use symbolic computation, or employ continuous procedures with stopping criteria.</p>
    </div>

    <div class="property-card">
      <h3>Individual vs. Group Optimality</h3>
      <p class="property-description">
        <strong>Competing Perspectives:</strong> What's fair for individuals may not optimize group outcomes.
      </p>
      
      <div class="proof-sketch">
        <p><strong>Envy-freeness Focus:</strong> Ensures no individual feels wronged, but may not maximize collective satisfaction.</p>
        
        <p><strong>Utilitarian Alternative:</strong> Maximize $\sum_i v_i(\text{piece}_i)$ (total utility) but may leave some players feeling unfairly treated.</p>
        
        <p><strong>Egalitarian Tension:</strong> Minimize $\max_i v_i(\text{piece}_i) - \min_j v_j(\text{piece}_j)$ (reduce inequality) but may reduce overall welfare.</p>
      </div>
      
      <p><strong>Philosophical Question:</strong> Should algorithms prioritize individual rights or collective welfare when they conflict?</p>
    </div>

    <div class="property-card">
      <h3>Robustness vs. Performance</h3>
      <p class="property-description">
        <strong>Worst-case vs. Average-case:</strong> Protecting against pathological inputs limits performance on typical inputs.
      </p>
      
      <div class="proof-sketch">
        <p><strong>Robust Design:</strong> Algorithms that work well for all possible preference profiles may be overly conservative for realistic preferences.</p>
        
        <p><strong>Performance Cost:</strong> Adding robustness against strategic manipulation or extreme preferences often reduces efficiency for "well-behaved" cases.</p>
        
        <p><strong>Example:</strong> Auction mechanisms that prevent collusion may be unnecessarily complex when bidders are honestly competing.</p>
      </div>
      
      <p><strong>Design Question:</strong> How much performance should we sacrifice to handle edge cases that may never occur in practice?</p>
    </div>
  </div>
</div>

<div class="content-block">
  <h2>Exploring Trade-offs in Practice</h2>
  <p>Use our algorithm simulator to see these trade-offs in action:</p>

  <div class="exploration-grid">
    <div class="exploration-item">
      <h4>Efficiency vs. Fairness</h4>
      <p>Create scenarios with very different player preferences and compare total welfare across algorithms.</p>
      <a href="/fair-division-algorithms/exercises/" class="algorithm-link">Try Different Algorithms →</a>
    </div>

    <div class="exploration-item">
      <h4>Simplicity vs. Guarantees</h4>
      <p>Compare Divide-and-Choose (simple, 2-player) with Selfridge-Conway (complex, envy-free 3-player).</p>
      <a href="/fair-division-algorithms/exercises/" class="algorithm-link">Compare Complexity →</a>
    </div>

    <div class="exploration-item">
      <h4>Precision vs. Practicality</h4>
      <p>See how Austin's Moving Knife (exact, infinite) compares with discrete approximations.</p>
      <a href="/fair-division-algorithms/exercises/" class="algorithm-link">Test Precision →</a>
    </div>
  </div>
</div>

<footer class="algorithm-navigation">
  <a href="/fair-division-algorithms/impossibility/" class="nav-button secondary">← Impossibility</a>
  <a href="/fair-division-algorithms/theory/" class="nav-button primary">Back to Theory →</a>
</footer>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron</p>
        <p class="footer-credits">Washington University in St. Louis received financial support from Mozilla Responsible Computer Science</p>
    </div>
</footer>

<!-- JavaScript Libraries -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">▼</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>