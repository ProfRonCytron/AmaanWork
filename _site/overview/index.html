<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Models of Computation | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main.css">

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Models of Computation | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Models of Computation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<meta property="og:description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/overview/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/overview/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Models of Computation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.","headline":"Models of Computation","url":"http://localhost:4000/fair-division-algorithms/overview/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="page-header">
  <h1 class="page-title">Models of Computation for Cake-Cutting</h1>
  <p class="page-description">Frameworks for analyzing algorithmic complexity in fair division</p>
</div>

<div class="content-block">
  <h2>Overview</h2>
  <p>Reasoning about the run-time complexity of fair division algorithms requires a model of computation. Each model captures different aspects of the information revelation process and leads to different complexity measures. Understanding these models is essential for comparing algorithms and establishing theoretical bounds.</p>
</div>

<div class="content-block">
  <h2>Four Fundamental Models</h2>

  <div class="properties-grid">

    <div class="property-card">
      <h3><a href="/fair-division-algorithms/robertson-webb-query-model/">Robertson-Webb Query Model</a></h3>
      <p class="property-description">
        The standard model for discrete cake-cutting algorithms using two query types.
      </p>
      <ul>
        <li><strong>Cut Query:</strong> "Mark a piece of cake with a given value"</li>
        <li><strong>Eval Query:</strong> "Evaluate a given piece of cake"</li>
      </ul>
      <p><strong>Complexity Measure:</strong> Number of queries required</p>
      <p><strong>Best For:</strong> Discrete protocols, lower bound proofs</p>
    </div>

    <div class="property-card">
      <h3><a href="/fair-division-algorithms/moving-knife-model/">Moving-Knives Model</a></h3>
      <p class="property-description">
        Continuous procedures where knives move until players signal satisfaction.
      </p>
      <ul>
        <li>Continuous knife movement over the cake</li>
        <li>Players shout "stop" at critical moments</li>
      </ul>
      <p><strong>Complexity Measure:</strong> Number of knife movements and stops</p>
      <p><strong>Best For:</strong> Exact fair division, envy-free procedures</p>
    </div>

    <div class="property-card">
      <h3><a href="/fair-division-algorithms/direct-revelation-model/">Direct Revelation Model</a></h3>
      <p class="property-description">
        Players reveal their entire valuation function to the mechanism.
      </p>
      <ul>
        <li>Complete preference revelation upfront</li>
        <li>Works for succinctly representable valuations</li>
      </ul>
      <p><strong>Complexity Measure:</strong> Representation size of valuations</p>
      <p><strong>Best For:</strong> Piecewise-uniform, piecewise-constant, or piecewise-linear valuations</p>
    </div>

    <div class="property-card">
      <h3><a href="/fair-division-algorithms/simultaneous-queries-model/">Simultaneous Reports Model</a></h3>
      <p class="property-description">
        Players simultaneously submit discretized valuation reports.
      </p>
      <ul>
        <li>Agents report sequences of cut-points</li>
        <li>Values of pieces between cut-points</li>
      </ul>
      <p><strong>Complexity Measure:</strong> Number of cut-points required</p>
      <p><strong>Best For:</strong> Protocol design, approximation algorithms</p>
    </div>

  </div>
</div>

<div class="content-block">
  <h2>Model Comparison</h2>

  <table class="comparison-table">
    <thead>
      <tr>
        <th>Model</th>
        <th>Information Revelation</th>
        <th>Complexity Metric</th>
        <th>Typical Bounds</th>
        <th>Key Algorithms</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Robertson-Webb</strong></td>
        <td>Incremental queries</td>
        <td>Query count</td>
        <td>O(n log n) for proportional</td>
        <td>Divide-and-Choose, Even-Paz</td>
      </tr>
      <tr>
        <td><strong>Moving-Knives</strong></td>
        <td>Continuous monitoring</td>
        <td>Knife movements</td>
        <td>Often unbounded</td>
        <td>Austin, Stromquist</td>
      </tr>
      <tr>
        <td><strong>Direct Revelation</strong></td>
        <td>Complete upfront</td>
        <td>Representation size</td>
        <td>O(n) for piecewise-linear</td>
        <td>Linear programming methods</td>
      </tr>
      <tr>
        <td><strong>Simultaneous Reports</strong></td>
        <td>Discretized batch</td>
        <td>Discretization points</td>
        <td>O(n²) for ε-approximation</td>
        <td>Approximation protocols</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="content-block">
  <h2>Choosing the Right Model</h2>

  <h3>Key Considerations</h3>

  <div class="consideration-grid">
    <div class="consideration-item">
      <h4>1. Valuation Function Complexity</h4>
      <p>Simple valuations (piecewise-constant) may benefit from direct revelation, while complex valuations require query-based approaches.</p>
    </div>

    <div class="consideration-item">
      <h4>2. Exactness Requirements</h4>
      <p>Moving-knife procedures achieve exact fairness but at the cost of continuous computation. Query models often trade exactness for finite complexity.</p>
    </div>

    <div class="consideration-item">
      <h4>3. Strategic Considerations</h4>
      <p>Robertson-Webb queries reveal minimal information, supporting strategy-proof mechanisms. Direct revelation requires careful incentive design.</p>
    </div>

    <div class="consideration-item">
      <h4>4. Implementation Feasibility</h4>
      <p>Query models translate naturally to interactive protocols. Moving-knife procedures are often theoretical, requiring discretization for implementation.</p>
    </div>
  </div>
</div>

<div class="content-block">
  <h2>Theoretical Implications</h2>

  <h3>Lower Bounds Across Models</h3>
  <p>Different models yield different lower bounds for the same problem:</p>

  <ul>
    <li><strong>Proportional division for n players:</strong>
      <ul>
        <li>Robertson-Webb: Ω(n log n) queries</li>
        <li>Direct Revelation: Ω(n) communication complexity</li>
        <li>Moving-Knives: Can be achieved with bounded movements</li>
      </ul>
    </li>
    <li><strong>Envy-free division for n players:</strong>
      <ul>
        <li>Robertson-Webb: No finite bound known for n ≥ 4</li>
        <li>Moving-Knives: Finite procedures exist (Stromquist, Barbanel-Brams)</li>
        <li>Simultaneous Reports: Approximation possible with O(n³/ε) cut-points</li>
      </ul>
    </li>
  </ul>

  <h3>Model Relationships</h3>
  <p>These models are not independent but form a hierarchy of expressiveness:</p>

  <div class="proof-sketch">
    <p><strong>Theorem:</strong> Any algorithm in the Robertson-Webb model can be simulated in the direct revelation model with at most exponential blow-up in complexity.</p>

    <p><strong>Intuition:</strong> The direct revelation model can simulate query responses by computing them from the full valuation function. However, this may require exponentially many bits to represent arbitrary valuations that could be queried efficiently.</p>
  </div>
</div>

<div class="content-block">
  <h2>Practical Applications</h2>

  <h3>Interactive Implementations</h3>
  <p>For educational demonstrations and practical systems:</p>

  <ul>
    <li><strong>Robertson-Webb queries</strong> map directly to user interface elements (sliders, evaluation displays)</li>
    <li><strong>Moving-knife simulations</strong> require discretization into time steps</li>
    <li><strong>Direct revelation</strong> works well when preferences can be specified via simple parameters</li>
    <li><strong>Simultaneous reports</strong> enable batch processing and parallel computation</li>
  </ul>

  <h3>Real-World Constraints</h3>
  <p>Each model makes different assumptions about practical feasibility:</p>

  <div class="warning-box">
    <p><strong>Important:</strong> While moving-knife procedures provide elegant theoretical solutions, they often cannot be directly implemented due to:</p>
    <ul>
      <li>Requirement for truly continuous time</li>
      <li>Perfect synchronization between players</li>
      <li>Infinite precision in measurements</li>
    </ul>
    <p>Practical implementations typically discretize these procedures, introducing approximation errors that must be carefully analyzed.</p>
  </div>
</div>

<footer class="algorithm-navigation">
  <a href="/fair-division-algorithms/theory/" class="nav-button secondary">← Theory Overview</a>
  <a href="/fair-division-algorithms/robertson-webb-query-model/" class="nav-button primary">Robertson-Webb Model →</a>
</footer>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron.  Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.</p>
    </div>
</footer>

<!-- Import MathJax for LaTex Support -->
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Import scripts -->
<!-- Fair Division Demo System Scripts -->

<!-- Core demo system -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-system.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-controller.js"></script>

<!-- Indivisible goods extensions -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/indivisible-goods-extensions.js"></script>

<!-- Existing divisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/divide-and-choose.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/austins-moving-knife.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/steinhaus-lone-divider.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/selfridge-conway.js"></script>

<!-- Indivisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/knaster-sealed-bids.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/lucas-method-markers.js"></script>

<!-- Flowchart System -->
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-template-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/container-growth-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/query-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-state-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-animator.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-enhanced.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/data/algorithm-data.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/flowchart-factory.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/global-functions.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/initialization.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/exports.js"></script>

<script src=""></script>
<script src=""></script>

<script>
    // Initialize enhanced algorithm selector on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Wait for all scripts to load, then enhance the selector
        setTimeout(() => {
            enhanceAlgorithmSelector();
        }, 100);
    });

    // Enhanced algorithm selector with goods type grouping
    function enhanceAlgorithmSelector() {
        const selector = document.getElementById('algorithm-selector');
        if (!selector) return;

        // Get the demo system instance
        const demoSystem = window.FairDivisionCore.getInstance();
        if (!demoSystem) return;

        // Clear existing options
        selector.innerHTML = '<option value="">Select an algorithm...</option>';

        // Group algorithms by goods type
        const algorithmsByType = {
            'divisible': [],
            'discrete-items': [],
            'linear-arrangement': []
        };

        // Categorize registered algorithms
        demoSystem.algorithms.forEach((algorithm, id) => {
            const goodsType = algorithm.config.goodsType || 'divisible';
            if (algorithmsByType[goodsType]) {
                algorithmsByType[goodsType].push({ id, config: algorithm.config });
            }
        });

        // Create optgroups
        Object.entries(algorithmsByType).forEach(([type, algorithms]) => {
            if (algorithms.length > 0) {
                const optgroup = document.createElement('optgroup');

                // Set label based on goods type
                switch(type) {
                    case 'divisible':
                        optgroup.label = 'Divisible Goods (Continuous)';
                        break;
                    case 'discrete-items':
                        optgroup.label = 'Indivisible Goods (Discrete Items)';
                        break;
                    case 'linear-arrangement':
                        optgroup.label = 'Indivisible Goods (Linear Arrangement)';
                        break;
                    default:
                        optgroup.label = type.charAt(0).toUpperCase() + type.slice(1);
                }

                // Add algorithms to optgroup
                algorithms.forEach(({ id, config }) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = config.name;
                    optgroup.appendChild(option);
                });

                selector.appendChild(optgroup);
            }
        });

        console.log('[DEMO] Enhanced algorithm selector with goods type grouping');
    }
</script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">▼</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>