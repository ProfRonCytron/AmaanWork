<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stromquist Moving Knife Procedure | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main.css">

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Stromquist Moving Knife Procedure | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Stromquist Moving Knife Procedure" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<meta property="og:description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/algorithms/stromquist-moving-knife/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/algorithms/stromquist-moving-knife/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Stromquist Moving Knife Procedure" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.","headline":"Stromquist Moving Knife Procedure","url":"http://localhost:4000/fair-division-algorithms/algorithms/stromquist-moving-knife/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="algorithm-page">

  <!-- Algorithm Header Card -->
  <div class="algorithm-header-card">
    <div class="algorithm-header-content">
      <h1 class="algorithm-title">Stromquist Moving Knife Procedure</h1>
      <p class="algorithm-subtitle">The first envy-free moving knife procedure for three players</p>
      <div class="algorithm-meta">
        <span class="meta-badge players-badge">3 Players</span>
        <span class="meta-badge type-badge">Continuous</span>
        <span class="meta-badge complexity-badge">$\infty$ RW Queries</span>
      </div>
    </div>
  </div>

  <!-- Overview -->
  <section class="content-block">
    <h2>Overview</h2>
    <p>The Stromquist moving knife procedure, introduced by Walter Stromquist in 1980, was the first envy-free moving knife procedure devised for three players. This procedure was the first envy-free moving knife procedure devised for three players. It represents a landmark achievement in fair division theory, solving a problem that had remained unsolved for several decades.</p>
    <p>The procedure uses <strong>four knives simultaneously</strong>‚Äîone sword controlled by a referee and three knives controlled by the players‚Äîbut requires only <strong>two cuts</strong>, ensuring each player receives a single connected piece. It requires four knives but only two cuts, so each player receives a single connected piece.</p>
  </section>

  <!-- Flowchart -->
  <section class="content-block">
    <h2>Algorithm Flowchart</h2>
    <div id="enhanced-stromquist" data-enhanced-flowchart="stromquist-moving-knife"></div>

    <div class="animation-controls">
      <button class="animation-btn primary" onclick="animateAlgorithm('enhanced-stromquist', 1500)">
        ‚ñ∂Ô∏è Animate Steps
      </button>
      <button class="animation-btn secondary" onclick="resetAlgorithm('enhanced-stromquist')">
        üîÑ Reset
      </button>
    </div>
  </section>

  <!-- Fairness Properties -->
  <section class="content-block">
    <h2>Fairness Properties</h2>

    <div class="properties-grid">
      <div class="property-card">
        <h4>Envy-Free</h4>
        <p><strong>Guaranteed:</strong> Following this strategy each person gets the largest or one of the largest pieces by their own valuation and therefore the division is envy-free.</p>
        
        <div class="proof-sketch">
          <div class="proof-sketch-header" onclick="toggleProof('envy-free-proof')">
            <span><strong>Proof Sketch</strong></span>
            <span class="proof-toggle">‚ñ∂</span>
          </div>
          <div id="envy-free-proof" class="proof-sketch-content" style="display: none;">
            <p><strong>For the "Quieters" (non-shouting players):</strong> Each of them receives a piece that contains their own knife, so they do not envy each other. Additionally, because they remained quiet, the piece they receive is larger in their eyes than Left, so they also don't envy the shouter.</p>
            <p><strong>For the "Shouter":</strong> The shouter receives Left, which is equal to the piece they could receive by remaining silent and larger than the third piece, hence the shouter does not envy any of the quieters.</p>
          </div>
        </div>
      </div>

      <div class="property-card">
        <h4>Strategy-Proof</h4>
        <p><strong>Guaranteed:</strong> Truthful play (following the prescribed strategy) is optimal for each player, regardless of what others do.</p>
      </div>
    </div>
  </section>

  <!-- Historical Significance -->
  <section class="content-block">
    <h2>Historical Significance</h2>

    <p>The Stromquist procedure holds a unique place in fair division history:</p>
    
    <ul>
      <li><strong>Breakthrough Result:</strong> This problem was unsolved for several tens of years, until Stromquist (1980) suggested the following division protocol</li>
      <li><strong>First Envy-Free Solution:</strong> Solved the long-standing problem of envy-free division for three players with connected pieces</li>
      <li><strong>Methodological Innovation:</strong> Introduced the multi-knife coordination approach that influenced subsequent algorithms</li>
      <li><strong>Theoretical Foundation:</strong> Provided key insights that led to later impossibility results and complexity understanding</li>
    </ul>

    <div class="property-card">
      <h4>Theoretical Impact</h4>
      <p>Stromquist's work went beyond this single procedure. His later research (Stromquist, 2008) proved that <strong>finite protocols cannot achieve envy-free division</strong> with connected pieces for three or more players‚Äîestablishing fundamental limits in computational fair division.</p>
    </div>
  </section>

</div>

<!-- Navigation -->
<footer class="algorithm-navigation">
  <a href="/fair-division-algorithms/algorithms/selfridge-conway/" class="nav-button secondary">‚Üê Selfridge-Conway</a>
  <a href="/fair-division-algorithms/algorithms/banach-knaster-last-diminisher/" class="nav-button primary">Banach-Knaster ‚Üí</a>
</footer>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron.  Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.</p>
    </div>
</footer>

<!-- JavaScript Libraries -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">‚ñº</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>