<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Austin's Moving Knife | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main.css">

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Austin‚Äôs Moving Knife | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Austin‚Äôs Moving Knife" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science." />
<meta property="og:description" content="Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science." />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/algorithms/austins-moving-knife/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/algorithms/austins-moving-knife/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Austin‚Äôs Moving Knife" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science.","headline":"Austin‚Äôs Moving Knife","url":"http://localhost:4000/fair-division-algorithms/algorithms/austins-moving-knife/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/analysis/">Analysis</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="algorithm-page">

  <!-- Algorithm Header Card -->
  <div class="algorithm-header-card">
    <div class="algorithm-header-content">
      <h1 class="algorithm-title">Austin's Moving Knife</h1>
      <div class="algorithm-meta">
        <span class="meta-badge players-badge">2 Players</span>
        <span class="meta-badge type-badge">Continuous</span>
        <span class="meta-badge complexity-badge">$\infty$ RW Queries</span>
      </div>
    </div>
  </div>

  <!-- Overview -->
  <section class="content-block">
    <h2>Overview</h2>
    <p>Austin's procedure introduces a moving-knife mechanism to making a fair cake division. The procedure builds on Divide-and-Choose by guaranteeing exact divisions for two parties, rather than merely a proportional one.</p>
    <p>Austin's procedure relies on the <strong>intermediate value theorem</strong> to guarantee exact divisions. Let $f(x)$ represent Player 1's valuation of the cake from position 0 to position $x$, where the cake spans $[0,1]$. Since Player 1's valuation function is continuous and $f(0) = 0$ while $f(1) = 100$, there exists some position $x^* \in (0,1)$ such that $f(x^*) = 50$.</p>
    <p>During the knife-moving phase, the player in control maintains two knives at positions $L(t)$ and $R(t)$ such that their valuation of the piece between the knives remains constant:</p>
    $$v_1([L(t), R(t)]) = k \text{ for all } t$$
    <p>where $k$ is the value that player assigned to the initial piece when they first called "stop". The constraint that $L(T) = R(0)$ when $R(T) = 1$ ensures the entire cake is partitioned into exactly three pieces with valuations that sum to 100.</p>
    <a href="https://en.wikipedia.org/wiki/Austin_moving-knife_procedures" target="_blank" class="algorithm-link">Read more ‚Üí</a>
  </section>

  <!-- Flowchart -->
  <section class="content-block">
    <h2>Algorithm Flowchart</h2>
    <div id="enhanced-austins" data-enhanced-flowchart="austins-moving-knife"></div>
  </section>

  <!--  Animation Controls -->
  <div class="animation-controls">
    <button class="animation-btn primary" onclick="animateAlgorithm('enhanced-austins', 1200)">
        ‚ñ∂Ô∏è Animate Steps
    </button>
    <button class="animation-btn secondary" onclick="resetAlgorithm('enhanced-austins')">
        üîÑ Reset
    </button>
  </div>

  <!-- Fairness Properties -->

  <section class="content-block">
    <h2>Fairness Properties</h2>
    <p>Austin's procedure satisfies four fundamental fairness properties:</p>

    <h3>Equitable</h3>
    <p>Both players receive exactly 50% of their subjective valuation of the resource.</p>
    <div class="proof-sketch">
      <p><strong>Formal Statement:</strong> $\forall i \in \{1,2\}, v_i(\text{piece}_i) = 50$</p>

      <p><strong>Proof:</strong> When the first player calls "stop" in the initial phase, they believe the left piece has value exactly 50. During the two-knife phase, Player 1 maintains the middle piece at constant value $k$, while the constraint $L(T) = R(0)$ ensures the three pieces have values $(50-k, k, 50)$ according to Player 1.</p>

      <p>Player 2 calls "stop" when they believe the division creates pieces worth exactly 50 each according to their valuation. Since pieces are randomly assigned, both players receive exactly 50% in expectation according to their own valuations.</p>
    </div>

    <h3>Envy-free</h3>
    <p>Neither player prefers the other's allocation to their own.</p>
    <div class="proof-sketch">
      <p><strong>Formal Statement:</strong> $\forall i,j \in \{1,2\}, v_i(\text{piece}_i) \geq v_i(\text{piece}_j)$</p>
      <p><strong>Proof:</strong> When Player 2 calls "stop" in the final phase, they believe both pieces have equal value according to their valuation: $v_2(\text{piece}_A) = v_2(\text{piece}_B) = 50$. Therefore, Player 2 cannot envy either piece.</p>

      <p>For Player 1, the two-knife constraint ensures they value both final pieces equally at the moment of division. Since $v_1(\text{piece}_A) = v_1(\text{piece}_B)$, Player 1 also cannot experience envy regardless of the random assignment.</p>
    </div>

    <h3>Strategy-proof</h3>
    <p>Truth-telling is optimal for both players throughout the procedure.</p>
    <div class="proof-sketch">
      <p><strong>Formal Statement:</strong> Honest revelation of preferences is a dominant strategy for both players.</p>

      <p><strong>Proof by contradiction:</strong></p>

      <p><em>Phase 1:</em> If a player calls "stop" before they truly believe the left piece is worth 50, they risk receiving less than 50% if chosen to control the knives. If they wait too long, the other player will call "stop" first and gain control.</p>

      <p><em>Phase 2 (Player 1):</em> Misrepresenting valuations while moving the knives cannot improve the outcome, as Player 1 must maintain truthful valuations to satisfy the geometric constraints of the procedure.</p>

      <p><em>Phase 2 (Player 2):</em> Calling "stop" before truly believing in a 50-50 division risks receiving a piece worth less than 50% according to their true valuation. Waiting longer allows Player 1 to potentially create a division more favorable to Player 1.</p>
    </div>

    <a href="/theory/fairness-properties/" target="_blank" class="algorithm-link">Learn more about fairness properties ‚Üí</a>
  </section>

  <!-- Complexity Analysis -->
<section class="content-block">
  <h2>Computational Complexity</h2>
  <p>Austin's moving knife procedure presents a fundamental challenge in the Robertson-Webb query model due to its continuous nature:</p>

  <h3>Theoretical Query Complexity: O(‚àû)</h3>
  <p>Unlike discrete algorithms, Austin's procedure requires <strong>unbounded query complexity</strong> because:</p>
  <ol>
    <li><strong>Phase 1:</strong> Continuous evaluation as the knife moves - players must assess "Is the left piece exactly 50%?" at every infinitesimal position</li>
    <li><strong>Phase 2:</strong> Dual knife coordination requiring continuous monitoring of piece values while maintaining geometric constraints</li>
    <li><strong>Exactness Requirement:</strong> Achieving perfect 50-50 division fundamentally requires infinite precision</li>
  </ol>

  <a href="/analysis/" target="_blank" class="algorithm-link">Compare with other algorithms ‚Üí</a>

  <h3>Œµ-Approximate Implementation: O(log(1/Œµ))</h3>
  <p>For any approximation parameter Œµ &gt; 0, we can achieve an <strong>Œµ-exact division</strong> where each player receives a piece valued between $(50-Œµ)$ and $(50+Œµ)$ percent of their total valuation.</p>

  <div class="definition-box" style="background: #f0f9ff; padding: 1rem; border-left: 4px solid #3182ce; margin: 1rem 0;">
    <h4>Definition: Œµ-Exact Division</h4>
    <p>A division is <strong>Œµ-exact</strong> if for each player $i$:</p>
    $$|v_i(\text{piece}_i) - 50| \leq Œµ$$
    <p>where $v_i(\text{piece}_i)$ is player $i$'s valuation of their allocated piece as a percentage of their total valuation.</p>
  </div>

  <p><strong>Query Complexity Result:</strong> Any Œµ-exact division for 2 players can be computed using <strong>O(log(1/Œµ))</strong> Robertson-Webb queries.</p>

  <div class="proof-sketch">
    <p><strong>Intuition for the O(log(1/Œµ)) Bound:</strong></p>
    <p>Binary search can locate a cut position within Œµ-precision of the exact 50% point. Each query halves the search interval, so achieving precision Œµ requires approximately $\log_2(1/Œµ)$ queries.</p>

    <p><strong>Mathematical Example:</strong> To guarantee each player receives between 49.9% and 50.1% (Œµ = 0.1), we need $\log_2(10) ‚âà 3.3$ queries, so at most 4 Robertson-Webb queries suffice.</p>
    
    <p><strong>The Exactness Barrier:</strong> True exactness (Œµ = 0) requires $\log(1/0) = ‚àû$ queries, which is why Austin's theoretical guarantee of perfect 50-50 division cannot be achieved with finite Robertson-Webb queries.</p>
  </div>
  
</section>

  <!-- Navigation -->
  <footer class="algorithm-navigation">
    <a href="/fair-division-algorithms/algorithms/divide-and-choose/" class="nav-button secondary">‚Üê Back to Divide-and-Choose</a>
    <a href="/fair-division-algorithms/algorithms/steinhaus-lone-divider/" class="nav-button primary">Next: Steinhaus' Lone-Divider ‚Üí</a>
  </footer>
</div>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">Interactive educational platform developed by Amaan Khan and Dr. Ron Cytron.  Washington University in St. Louis received financial support from Mozilla Responsible Computer Science.</p>
    </div>
</footer>

<!-- JavaScript Libraries -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">‚ñº</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>