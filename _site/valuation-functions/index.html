<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valuation Functions | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main.css">

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Valuation Functions | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Valuation Functions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<meta property="og:description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/valuation-functions/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/valuation-functions/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Valuation Functions" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.","headline":"Valuation Functions","url":"http://localhost:4000/fair-division-algorithms/valuation-functions/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="page-header">
  <h1 class="page-title">Valuation Functions</h1>
  <p class="page-description">Mathematical representations of preferences in fair division</p>
</div>

<div class="content-block">
  <h2>Overview</h2>
  <p>Valuation functions are the mathematical bridge between subjective human preferences and objective algorithmic procedures. They encode how each player values different portions of the divisible resource, enabling algorithms to compute fair allocations based on these preferences.</p>

  <p>Understanding the structure and properties of valuation functions is crucial for algorithm design, as different assumptions about valuations lead to different computational possibilities and complexity bounds.</p>
</div>

<div class="content-block">
  <h2>Formal Definition</h2>

  <div class="definition-box">
    <p><strong>Definition:</strong> A valuation function for player $i$ is a mapping:</p>
    $$v_i: 2^X \rightarrow \mathbb{R}_+$$
    <p>where $X = [0,1]$ is the cake and $2^X$ denotes the set of all measurable subsets of $X$.</p>
  </div>

  <h3>Essential Properties</h3>

  <div class="properties-grid">
    <div class="property-card">
      <h3>Non-negativity</h3>
      <p>$v_i(S) \geq 0$ for all measurable $S \subseteq X$</p>
      <p><strong>Interpretation:</strong> No part of the resource has negative value</p>
    </div>

    <div class="property-card">
      <h3>Normalization</h3>
      <p>$v_i(X) = 1$ (or sometimes 100)</p>
      <p><strong>Purpose:</strong> Enables comparison across players</p>
    </div>

    <div class="property-card">
      <h3>Additivity</h3>
      <p>$v_i(A \cup B) = v_i(A) + v_i(B)$ for disjoint $A, B$</p>
      <p><strong>Meaning:</strong> No complementarities between pieces</p>
    </div>

    <div class="property-card">
      <h3>Monotonicity</h3>
      <p>$A \subseteq B \Rightarrow v_i(A) \leq v_i(B)$</p>
      <p><strong>Logic:</strong> Larger pieces have at least as much value</p>
    </div>
  </div>
</div>

<div class="content-block">
  <h2>Types of Valuation Functions</h2>

  <h3>Uniform Valuations</h3>
  <p>The simplest case where value is proportional to length:</p>
  $$v_i([a,b]) = b - a$$

  <ul>
    <li>All players agree on piece values</li>
    <li>Fair division becomes trivial (equal lengths)</li>
    <li>Useful as a baseline for complexity analysis</li>
  </ul>

  <h3>Piecewise Constant</h3>
  <p>The cake is divided into regions with uniform value density:</p>

  <div class="proof-sketch">
    <p><strong>Example:</strong> A cake with chocolate, vanilla, and strawberry sections</p>
    <pre>
    v_i([a,b]) = Σ_j (density_j × length_in_region_j)
    </pre>
    <p>Common in practical applications where resources have discrete types</p>
  </div>

  <h3>Piecewise Linear</h3>
  <p>Value density changes linearly within regions:</p>
  <ul>
    <li>More expressive than piecewise constant</li>
    <li>Still computationally tractable</li>
    <li>Can approximate smooth functions arbitrarily well</li>
  </ul>

  <h3>General Continuous</h3>
  <p>Arbitrary continuous density functions:</p>
  $$v_i([a,b]) = \int_a^b f_i(x) dx$$

  <div class="warning-box">
    <p><strong>Computational Challenge:</strong> May require infinite precision to represent exactly. Algorithms must work with query access rather than explicit representation.</p>
  </div>
</div>

<div class="content-block">
  <h2>Special Classes of Valuations</h2>

  <h3>Single-Peaked Preferences</h3>
  <p>Value density has a single maximum:</p>
  <ul>
    <li>Models preferences with an "ideal point"</li>
    <li>Enables efficient algorithms for some problems</li>
    <li>Common in spatial resource allocation</li>
  </ul>

  <h3>Responsive Valuations</h3>
  <p>Small changes in allocation lead to small changes in value:</p>

  <div class="theorem-box">
    <p><strong>Definition:</strong> A valuation is $\epsilon$-responsive if for any interval $[a,b]$ and $\delta &gt; 0$:</p>
    $$|v_i([a,b]) - v_i([a,b+\delta])| \leq \epsilon \cdot \delta$$
  </div>

  <h3>Hungry Valuations</h3>
  <p>Every piece has positive value:</p>
  $$v_i(S) &gt; 0 \text{ for all } S \text{ with positive measure}$$

  <ul>
    <li>Ensures players always want more</li>
    <li>Simplifies certain impossibility proofs</li>
    <li>Realistic for many resources</li>
  </ul>
</div>

<div class="content-block">
  <h2>Valuation Elicitation</h2>

  <h3>The Information Problem</h3>
  <p>Algorithms must learn about valuations through queries:</p>

  <table class="comparison-table">
    <thead>
      <tr>
        <th>Query Type</th>
        <th>Information Revealed</th>
        <th>Typical Use</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Value Query</strong></td>
        <td>$v_i([a,b])$ for specific interval</td>
        <td>Comparing pieces</td>
      </tr>
      <tr>
        <td><strong>Cut Query</strong></td>
        <td>Position for desired value</td>
        <td>Making proportional cuts</td>
      </tr>
      <tr>
        <td><strong>Comparison Query</strong></td>
        <td>Preference between two pieces</td>
        <td>Ordinal mechanisms</td>
      </tr>
    </tbody>
  </table>

  <h3>Communication Complexity</h3>
  <p>How much information must be exchanged to compute fair allocations?</p>

  <ul>
    <li><strong>Lower bounds:</strong> Minimum queries needed for any algorithm</li>
    <li><strong>Upper bounds:</strong> Queries used by best known algorithms</li>
    <li><strong>Gaps:</strong> Often exponential between upper and lower bounds</li>
  </ul>
</div>

<div class="content-block">
  <h2>Probabilistic Valuations</h2>

  <h3>Measure-Theoretic Foundation</h3>
  <p>Valuations as probability measures on $[0,1]$:</p>

  <div class="definition-box">
    <p>A valuation $v_i$ is a probability measure if:</p>
    <ol>
      <li>$v_i(X) = 1$ (normalization)</li>
      <li>$v_i(A) \geq 0$ for all measurable $A$</li>
      <li>$v_i(\bigcup_j A_j) = \sum_j v_i(A_j)$ for disjoint $\{A_j\}$</li>
    </ol>
  </div>

  <p>This perspective enables:</p>
  <ul>
    <li>Use of probabilistic tools and inequalities</li>
    <li>Connection to random allocation mechanisms</li>
    <li>Analysis of expected fairness properties</li>
  </ul>
</div>

<div class="content-block">
  <h2>Computational Representations</h2>

  <h3>Explicit Representations</h3>

  <div class="implementation-grid">
    <div class="implementation-item">
      <h4>Piecewise Constant</h4>
      <pre>
values = [(0, 0.3, 2.0),
          (0.3, 0.7, 1.0),
          (0.7, 1.0, 3.0)]
      </pre>
    </div>

    <div class="implementation-item">
      <h4>Polynomial</h4>
      <pre>
density(x) = a₀ + a₁x + a₂x² + ... + aₙxⁿ
      </pre>
    </div>

    <div class="implementation-item">
      <h4>Sample Points</h4>
      <pre>
samples = {0: 0, 0.1: 0.08,
           0.2: 0.15, ...}
      </pre>
    </div>

    <div class="implementation-item">
      <h4>Functional</h4>
      <pre>
v(a,b) = integrate(density, a, b)
      </pre>
    </div>
  </div>

  <h3>Oracle Access</h3>
  <p>For complex valuations, algorithms access valuations only through queries:</p>

  <ul>
    <li>Treats valuation as a "black box"</li>
    <li>Focuses on information-theoretic complexity</li>
    <li>Enables handling of arbitrary valuations</li>
  </ul>
</div>

<div class="content-block">
  <h2>Applications Beyond Cake-Cutting</h2>

  <h3>Multi-Dimensional Resources</h3>
  <ul>
    <li><strong>Land division:</strong> 2D valuations over geographic regions</li>
    <li><strong>Time allocation:</strong> Valuations over time intervals</li>
    <li><strong>Computational resources:</strong> CPU, memory, bandwidth preferences</li>
  </ul>

  <h3>Discrete Items</h3>
  <p>Valuations over indivisible goods:</p>
  <ul>
    <li>Additive: $v(S) = \sum_{i \in S} v(\{i\})$</li>
    <li>Submodular: Diminishing returns</li>
    <li>Supermodular: Complementarities</li>
  </ul>

  <h3>Hybrid Settings</h3>
  <p>Combining divisible and indivisible resources requires unified valuation frameworks</p>
</div>

<footer class="algorithm-navigation">
  <a href="/fair-division-algorithms/fairness-properties/" class="nav-button secondary">← Fairness Properties</a>
  <a href="/fair-division-algorithms/existence-theory/" class="nav-button primary">Existence Theory →</a>
</footer>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron.  Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.</p>
    </div>
</footer>

<!-- Import MathJax for LaTex Support -->
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Import scripts -->
<!-- Fair Division Demo System Scripts -->

<!-- Core demo system -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-system.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-controller.js"></script>

<!-- Indivisible goods extensions -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/indivisible-goods-extensions.js"></script>

<!-- Existing divisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/divide-and-choose.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/austins-moving-knife.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/steinhaus-lone-divider.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/selfridge-conway.js"></script>

<!-- Indivisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/knaster-sealed-bids.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/lucas-method-markers.js"></script>

<!-- Flowchart System -->
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-template-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/container-growth-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/query-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-state-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-animator.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-enhanced.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/data/algorithm-data.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/flowchart-factory.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/global-functions.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/initialization.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/exports.js"></script>

<script src=""></script>
<script src=""></script>

<script>
    // Initialize enhanced algorithm selector on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Wait for all scripts to load, then enhance the selector
        setTimeout(() => {
            enhanceAlgorithmSelector();
        }, 100);
    });

    // Enhanced algorithm selector with goods type grouping
    function enhanceAlgorithmSelector() {
        const selector = document.getElementById('algorithm-selector');
        if (!selector) return;

        // Get the demo system instance
        const demoSystem = window.FairDivisionCore.getInstance();
        if (!demoSystem) return;

        // Clear existing options
        selector.innerHTML = '<option value="">Select an algorithm...</option>';

        // Group algorithms by goods type
        const algorithmsByType = {
            'divisible': [],
            'discrete-items': [],
            'linear-arrangement': []
        };

        // Categorize registered algorithms
        demoSystem.algorithms.forEach((algorithm, id) => {
            const goodsType = algorithm.config.goodsType || 'divisible';
            if (algorithmsByType[goodsType]) {
                algorithmsByType[goodsType].push({ id, config: algorithm.config });
            }
        });

        // Create optgroups
        Object.entries(algorithmsByType).forEach(([type, algorithms]) => {
            if (algorithms.length > 0) {
                const optgroup = document.createElement('optgroup');

                // Set label based on goods type
                switch(type) {
                    case 'divisible':
                        optgroup.label = 'Divisible Goods (Continuous)';
                        break;
                    case 'discrete-items':
                        optgroup.label = 'Indivisible Goods (Discrete Items)';
                        break;
                    case 'linear-arrangement':
                        optgroup.label = 'Indivisible Goods (Linear Arrangement)';
                        break;
                    default:
                        optgroup.label = type.charAt(0).toUpperCase() + type.slice(1);
                }

                // Add algorithms to optgroup
                algorithms.forEach(({ id, config }) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = config.name;
                    optgroup.appendChild(option);
                });

                selector.appendChild(optgroup);
            }
        });

        console.log('[DEMO] Enhanced algorithm selector with goods type grouping');
    }
</script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">▼</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>