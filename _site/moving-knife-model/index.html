<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moving-Knife Model | Fair Division Algorithms</title>

    <!-- Fixed CSS paths -->
    <link rel="stylesheet" href="/fair-division-algorithms/assets/css/main.css">

    <!-- Fixed favicon paths -->
    <link rel="icon" type="image/svg+xml" href="/fair-division-algorithms/assets/favicon/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/fair-division-algorithms/assets/favicon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/fair-division-algorithms/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/fair-division-algorithms/assets/favicon/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/fair-division-algorithms/assets/favicon/apple-touch-icon.png">

    <meta name="theme-color" content="#3182ce">

    <!-- MathJax Configuration - MUST come before script load -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Moving-Knife Model | Fair Division Algorithms</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Moving-Knife Model" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<meta property="og:description" content="An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project." />
<link rel="canonical" href="http://localhost:4000/fair-division-algorithms/moving-knife-model/" />
<meta property="og:url" content="http://localhost:4000/fair-division-algorithms/moving-knife-model/" />
<meta property="og:site_name" content="Fair Division Algorithms" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Moving-Knife Model" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron. Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.","headline":"Moving-Knife Model","url":"http://localhost:4000/fair-division-algorithms/moving-knife-model/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
<!-- Site Header -->
<header class="site-header">
    <div class="container">
        <a href="/fair-division-algorithms/" class="site-title">Fair Division Algorithms</a>
        <nav class="site-nav">
            <a href="/fair-division-algorithms/theory/">Theory</a>
            <a href="/fair-division-algorithms/exercises/">Exercises + Simulator</a>
            <a href="/fair-division-algorithms/glossary/">Glossary</a>
            <a href="/fair-division-algorithms/references/">References</a>
        </nav>
    </div>
</header>

<!-- Main Content -->
<main class="main-content">
    <div class="container">
        <div class="page-header">
  <h1 class="page-title">Moving-Knife Model</h1>
  <p class="page-description">Continuous procedures for exact fair division through dynamic knife movements</p>
</div>

<div class="content-block">
  <h2>Overview</h2>
  <p>The moving-knife model represents a fundamentally different approach to fair division computation. Unlike the discrete Robertson-Webb model, moving-knife procedures operate in continuous time, with one or more "knives" moving continuously across the cake until players signal satisfaction by shouting "stop" at critical moments.</p>

  <p>These procedures often achieve exact fairness properties that are difficult or impossible to obtain with discrete algorithms, but at the cost of requiring continuous monitoring and perfect timing—features that complicate practical implementation.</p>
</div>

<div class="content-block">
  <h2>Core Mechanics</h2>

  <h3>Basic Components</h3>

  <div class="properties-grid">
    <div class="property-card">
      <h3>Knife Movement</h3>
      <p>One or more knives move continuously across the cake, typically from left to right</p>
      <ul>
        <li>Constant velocity or variable speed</li>
        <li>Single direction or oscillating</li>
        <li>Parallel or converging knives</li>
      </ul>
    </div>

    <div class="property-card">
      <h3>Player Signals</h3>
      <p>Players monitor the division and signal at critical value thresholds</p>
      <ul>
        <li>"Stop" when a piece reaches desired value</li>
        <li>"Mark" to indicate preference boundaries</li>
        <li>Continuous adjustments in some procedures</li>
      </ul>
    </div>

    <div class="property-card">
      <h3>Allocation Rules</h3>
      <p>Predetermined rules determine piece assignment when stops occur</p>
      <ul>
        <li>First to stop receives specific piece</li>
        <li>Random assignment among stoppers</li>
        <li>Iterative reduction of players/cake</li>
      </ul>
    </div>
  </div>
</div>

<div class="content-block">
  <h2>Classic Moving-Knife Algorithms</h2>

  <table class="comparison-table">
    <thead>
      <tr>
        <th>Algorithm</th>
        <th>Players</th>
        <th>Knives</th>
        <th>Properties</th>
        <th>Key Innovation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Dubins-Spanier</strong></td>
        <td>n</td>
        <td>1</td>
        <td>Proportional</td>
        <td>Single sweep, first-stop wins</td>
      </tr>
      <tr>
        <td><strong>Austin</strong></td>
        <td>2</td>
        <td>1→2</td>
        <td>Envy-free, Exact</td>
        <td>Two-phase: single then double knife</td>
      </tr>
      <tr>
        <td><strong>Stromquist</strong></td>
        <td>3</td>
        <td>4</td>
        <td>Envy-free</td>
        <td>Referee with sword, players with knives</td>
      </tr>
      <tr>
        <td><strong>Barbanel-Brams</strong></td>
        <td>n</td>
        <td>Multiple</td>
        <td>Envy-free</td>
        <td>Recursive reduction with moving knives</td>
      </tr>
      <tr>
        <td><strong>Webb</strong></td>
        <td>n</td>
        <td>n-1</td>
        <td>Exact division</td>
        <td>Creates n pieces of exactly equal value</td>
      </tr>
    </tbody>
  </table>

  <h3>Detailed Example: Austin's Moving-Knife Procedure</h3>

  <div class="proof-sketch">
    <p><strong>Phase 1: Single Knife</strong></p>
    <ol>
      <li>A knife moves continuously from left to right</li>
      <li>Both players monitor the value of the left piece</li>
      <li>When either player believes the left piece equals 1/2, they shout "stop"</li>
      <li>A coin flip determines who becomes the "cutter" for Phase 2</li>
    </ol>

    <p><strong>Phase 2: Two Knives</strong></p>
    <ol>
      <li>The cutter places a second knife to the right of the first</li>
      <li>Both knives move right in parallel, maintaining equal values for the cutter</li>
      <li>When the other player sees two pieces of equal value, they shout "stop"</li>
      <li>That player chooses one piece; the cutter gets the other</li>
    </ol>

    <p><strong>Result:</strong> Exact envy-free division—both players value their piece at exactly 1/2</p>
  </div>
</div>

<div class="content-block">
  <h2>Computational Complexity Analysis</h2>

  <h3>Measuring Complexity in Continuous Time</h3>

  <p>The moving-knife model presents unique challenges for complexity analysis:</p>

  <ul>
    <li><strong>Time complexity:</strong> Often measured in "time units" of knife movement</li>
    <li><strong>Number of knives:</strong> Hardware complexity of the procedure</li>
    <li><strong>Number of stops:</strong> Discrete decision points in continuous process</li>
    <li><strong>Convergence rate:</strong> How quickly knives reach final positions</li>
  </ul>

  <div class="warning-box">
    <p><strong>Key Challenge:</strong> Most moving-knife procedures have <em>unbounded</em> complexity in the Robertson-Webb model, as they require continuous monitoring that cannot be captured by finite discrete queries.</p>
  </div>

  <h3>Complexity Comparison</h3>

  <table class="comparison-table">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Robertson-Webb</th>
        <th>Moving-Knife</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Query Type</strong></td>
        <td>Discrete CUT/EVAL</td>
        <td>Continuous monitoring</td>
      </tr>
      <tr>
        <td><strong>Information Flow</strong></td>
        <td>Sequential revelation</td>
        <td>Simultaneous observation</td>
      </tr>
      <tr>
        <td><strong>Precision</strong></td>
        <td>Approximate possible</td>
        <td>Exact achievable</td>
      </tr>
      <tr>
        <td><strong>Implementation</strong></td>
        <td>Natural digital implementation</td>
        <td>Requires discretization</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="content-block">
  <h2>Advantages and Limitations</h2>

  <div class="properties-grid">
    <div class="property-card">
      <h3>Advantages</h3>
      <ul>
        <li><strong>Exact fairness:</strong> Achieves perfect envy-freeness or exact division</li>
        <li><strong>Existence proofs:</strong> Demonstrates that fair divisions exist</li>
        <li><strong>Elegant solutions:</strong> Often simpler conceptually than discrete alternatives</li>
        <li><strong>Stronger properties:</strong> Can achieve fairness combinations impossible discretely</li>
      </ul>
    </div>

    <div class="property-card">
      <h3>Limitations</h3>
      <ul>
        <li><strong>Continuous time:</strong> Requires infinite precision timing</li>
        <li><strong>Perfect coordination:</strong> Players must monitor and react instantaneously</li>
        <li><strong>Physical constraints:</strong> Actual knives cannot move infinitesimally</li>
        <li><strong>Cognitive load:</strong> Continuous evaluation is mentally demanding</li>
      </ul>
    </div>
  </div>
</div>

<div class="content-block">
  <h2>Discretization and Implementation</h2>

  <h3>From Continuous to Discrete</h3>

  <p>Practical implementation requires discretizing moving-knife procedures:</p>

  <div class="implementation-grid">
    <div class="implementation-item">
      <h4>Time Discretization</h4>
      <p>Divide continuous movement into discrete time steps Δt</p>
      <ul>
        <li>Trade-off: Smaller Δt → better approximation but more computation</li>
        <li>Error bound: O(Δt) for most procedures</li>
      </ul>
    </div>

    <div class="implementation-item">
      <h4>Value Discretization</h4>
      <p>Round values to finite precision ε</p>
      <ul>
        <li>ε-envy-free instead of exactly envy-free</li>
        <li>Query complexity: O(1/ε) evaluations</li>
      </ul>
    </div>

    <div class="implementation-item">
      <h4>Space Discretization</h4>
      <p>Limit knife positions to discrete points</p>
      <ul>
        <li>Grid of n possible cut positions</li>
        <li>Complexity: O(n²) for most procedures</li>
      </ul>
    </div>
  </div>

  <h3>Implementation Strategies</h3>

  <div class="proof-sketch">
    <p><strong>Algorithm: Discretized Austin Procedure</strong></p>
    <pre>
    // Phase 1: Find initial cut
    position = 0
    step_size = 1/precision
    while no_player_called_stop:
        position += step_size
        if player_1_value(0, position) &gt;= 0.5 - ε:
            player_1_can_stop = true
        if player_2_value(0, position) &gt;= 0.5 - ε:
            player_2_can_stop = true

    // Phase 2: Parallel knife movement
    knife_1 = position
    knife_2 = position + step_size
    while not_equal_division:
        knife_1 += step_size
        knife_2 = find_equal_value_position(knife_1)
        if player_2_sees_equal_division(knife_1, knife_2):
            stop_and_allocate()
    </pre>
    <p><strong>Complexity:</strong> O(1/ε²) evaluation steps for ε-approximate envy-free division</p>
  </div>
</div>

<div class="content-block">
  <h2>Theoretical Significance</h2>

  <h3>Existence vs. Computation</h3>

  <p>Moving-knife procedures often serve as <em>existence proofs</em> rather than practical algorithms:</p>

  <ul>
    <li><strong>Stromquist (1980):</strong> Proved envy-free division exists for 3 players with connected pieces</li>
    <li><strong>Woodall (1980):</strong> Exact division possible for any number of players</li>
    <li><strong>Barbanel-Brams (2004):</strong> Envy-free exists for n players (non-constructive aspects)</li>
  </ul>

  <div class="theorem-box">
    <p><strong>Theorem (Stromquist, 1980):</strong> There exists a moving-knife procedure that produces an envy-free allocation of a cake among three players, where each player receives a connected piece.</p>

    <p><strong>Significance:</strong> This result is not known to be achievable by any finite discrete algorithm.</p>
  </div>

  <h3>Impossibility Results</h3>

  <p>Some moving-knife results highlight fundamental limitations:</p>

  <ul>
    <li>No finite Robertson-Webb algorithm known for envy-free connected pieces (3 players)</li>
    <li>Suggests inherent complexity difference between continuous and discrete models</li>
    <li>May indicate fundamental information-theoretic barriers</li>
  </ul>
</div>

<div class="content-block">
  <h2>Variants and Extensions</h2>

  <h3>Multi-Dimensional Moving Knives</h3>
  <ul>
    <li><strong>2D cake (land division):</strong> Moving lines or curves</li>
    <li><strong>Time-based resources:</strong> Moving temporal boundaries</li>
    <li><strong>Circular cake:</strong> Rotating radial knives</li>
  </ul>

  <h3>Hybrid Models</h3>
  <ul>
    <li><strong>Moving-knife with queries:</strong> Combine continuous movement with discrete checkpoints</li>
    <li><strong>Approximate moving-knife:</strong> Discrete simulation with convergence guarantees</li>
    <li><strong>Online moving-knife:</strong> Adapt to arriving players or changing preferences</li>
  </ul>

  <h3>Strategic Considerations</h3>
  <div class="warning-box">
    <p><strong>Important:</strong> Most moving-knife procedures are <em>not</em> strategy-proof. Players who can anticipate others' stopping points may gain advantage by strategic timing.</p>
  </div>
</div>

<div class="content-block">
  <h2>Research Frontiers</h2>

  <h3>Open Problems</h3>
  <ul>
    <li>Can every moving-knife procedure be approximated by a finite Robertson-Webb algorithm?</li>
    <li>What is the minimum number of moving knives needed for envy-free division of n players?</li>
    <li>Can moving-knife procedures be made strategy-proof through randomization?</li>
  </ul>

  <h3>Recent Developments</h3>
  <ul>
    <li><strong>Approximate implementations:</strong> Algorithms that ε-approximate moving-knife results</li>
    <li><strong>Complexity characterization:</strong> Understanding when continuous procedures have discrete equivalents</li>
    <li><strong>Practical protocols:</strong> Developing usable versions of moving-knife ideas</li>
  </ul>
</div>

<footer class="algorithm-navigation">
  <a href="/fair-division-algorithms/robertson-webb-query-model/" class="nav-button secondary">← Robertson-Webb Model</a>
  <a href="/fair-division-algorithms/direct-revelation-model/" class="nav-button primary">Direct Revelation Model →</a>
</footer>

    </div>
</main>

<!-- Site Footer -->
<footer class="site-footer">
    <div class="container">
        <h3 class="footer-title">Fair Division Algorithms</h3>
        <p class="footer-description">An interactive educational platform developed by Amaan Khan and Dr. Ron Cytron.  Washington University in St. Louis received financial support from Mozilla Responsible Computer Science for this project.</p>
    </div>
</footer>

<!-- Import MathJax for LaTex Support -->
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Import scripts -->
<!-- Fair Division Demo System Scripts -->

<!-- Core demo system -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-system.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/demo-controller.js"></script>

<!-- Indivisible goods extensions -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/core/indivisible-goods-extensions.js"></script>

<!-- Existing divisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/divide-and-choose.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/austins-moving-knife.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/steinhaus-lone-divider.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/divisible/selfridge-conway.js"></script>

<!-- Indivisible goods algorithms -->
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/knaster-sealed-bids.js"></script>
<script src="/fair-division-algorithms/assets/js/interactive-dashboard/algorithms/indivisible/lucas-method-markers.js"></script>

<!-- Flowchart System -->
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-template-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/container-growth-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/query-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-state-manager.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-animator.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/core/flowchart-enhanced.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/data/algorithm-data.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/flowchart-factory.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/global-functions.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/initialization.js"></script>
<script src="/fair-division-algorithms/assets/js/flowcharts/utils/exports.js"></script>

<script src=""></script>
<script src=""></script>

<script>
    // Initialize enhanced algorithm selector on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Wait for all scripts to load, then enhance the selector
        setTimeout(() => {
            enhanceAlgorithmSelector();
        }, 100);
    });

    // Enhanced algorithm selector with goods type grouping
    function enhanceAlgorithmSelector() {
        const selector = document.getElementById('algorithm-selector');
        if (!selector) return;

        // Get the demo system instance
        const demoSystem = window.FairDivisionCore.getInstance();
        if (!demoSystem) return;

        // Clear existing options
        selector.innerHTML = '<option value="">Select an algorithm...</option>';

        // Group algorithms by goods type
        const algorithmsByType = {
            'divisible': [],
            'discrete-items': [],
            'linear-arrangement': []
        };

        // Categorize registered algorithms
        demoSystem.algorithms.forEach((algorithm, id) => {
            const goodsType = algorithm.config.goodsType || 'divisible';
            if (algorithmsByType[goodsType]) {
                algorithmsByType[goodsType].push({ id, config: algorithm.config });
            }
        });

        // Create optgroups
        Object.entries(algorithmsByType).forEach(([type, algorithms]) => {
            if (algorithms.length > 0) {
                const optgroup = document.createElement('optgroup');

                // Set label based on goods type
                switch(type) {
                    case 'divisible':
                        optgroup.label = 'Divisible Goods (Continuous)';
                        break;
                    case 'discrete-items':
                        optgroup.label = 'Indivisible Goods (Discrete Items)';
                        break;
                    case 'linear-arrangement':
                        optgroup.label = 'Indivisible Goods (Linear Arrangement)';
                        break;
                    default:
                        optgroup.label = type.charAt(0).toUpperCase() + type.slice(1);
                }

                // Add algorithms to optgroup
                algorithms.forEach(({ id, config }) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = config.name;
                    optgroup.appendChild(option);
                });

                selector.appendChild(optgroup);
            }
        });

        console.log('[DEMO] Enhanced algorithm selector with goods type grouping');
    }
</script>

<!-- Proof Sketches and Interactive Elements -->
<script>
    // Initialize collapsible proof sketches after DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        // Wait for MathJax to finish rendering before initializing proof sketches
        if (window.MathJax && window.MathJax.startup) {
            window.MathJax.startup.promise.then(() => {
                initializeProofSketches();
            });
        } else {
            // Fallback if MathJax isn't loaded
            setTimeout(initializeProofSketches, 500);
        }
    });

    function initializeProofSketches() {
        // Find all existing proof-sketch divs and convert them
        const proofSketches = document.querySelectorAll('.proof-sketch');

        proofSketches.forEach(function (proofSketch, index) {
            // Skip if already initialized
            if (proofSketch.classList.contains('proof-sketch-initialized')) {
                return;
            }

            // Get the current content (preserving MathJax rendering)
            const originalContent = proofSketch.innerHTML;

            // Create the new structure
            const proofId = `proof-sketch-${index}`;

            // Create header element
            const header = document.createElement('div');
            header.className = 'proof-sketch-header';
            header.setAttribute('role', 'button');
            header.setAttribute('tabindex', '0');
            header.setAttribute('aria-expanded', 'false');
            header.setAttribute('aria-controls', `${proofId}-content`);
            header.setAttribute('data-proof-toggle', '');

            header.innerHTML = `
                    <span class="proof-sketch-title">Take a minute to think about why! Click here to see a proof.</span>
                    <span class="proof-sketch-toggle">▼</span>
                `;

            // Create content wrapper
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'proof-sketch-content';
            contentWrapper.id = `${proofId}-content`;
            contentWrapper.setAttribute('role', 'region');
            contentWrapper.setAttribute('aria-hidden', 'true');
            contentWrapper.innerHTML = originalContent;

            // Clear the original content and add new structure
            proofSketch.innerHTML = '';
            proofSketch.appendChild(header);
            proofSketch.appendChild(contentWrapper);

            // Mark as initialized
            proofSketch.classList.add('proof-sketch-initialized');

            // Add click event listener
            header.addEventListener('click', function () {
                toggleProofSketch(proofSketch);
            });

            // Add keyboard support (Enter and Space)
            header.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleProofSketch(proofSketch);
                }
            });
        });
    }

    function toggleProofSketch(proofSketch) {
        const header = proofSketch.querySelector('.proof-sketch-header');
        const content = proofSketch.querySelector('.proof-sketch-content');
        const title = proofSketch.querySelector('.proof-sketch-title');

        const isExpanded = proofSketch.classList.contains('expanded');

        if (isExpanded) {
            // Collapse
            proofSketch.classList.remove('expanded');
            header.setAttribute('aria-expanded', 'false');
            content.setAttribute('aria-hidden', 'true');
            title.textContent = 'Show Proof';

            // Reset max-height to 0 for smooth collapse
            content.style.maxHeight = '0px';

            // Reset padding after animation completes
            setTimeout(() => {
                if (!proofSketch.classList.contains('expanded')) {
                    content.style.padding = '0';
                }
            }, 400);

        } else {
            // Expand
            proofSketch.classList.add('expanded');
            header.setAttribute('aria-expanded', 'true');
            content.setAttribute('aria-hidden', 'false');
            title.textContent = 'Hide Proof';

            // Set padding first
            content.style.padding = '1rem';

            // Calculate proper max-height based on content (with some buffer)
            const contentHeight = content.scrollHeight;
            const bufferHeight = 50; // Add buffer for safety
            content.style.maxHeight = (contentHeight + bufferHeight) + 'px';

            // Optional: Scroll the proof into view if it's partially hidden
            setTimeout(() => {
                const rect = proofSketch.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    proofSketch.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }, 300);
        }
    }
</script>
</body>
</html>